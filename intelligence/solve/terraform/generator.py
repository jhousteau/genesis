"""Core Terraform generation from graph structures."""

from typing import Optional

import structlog

from .dependency_translator import DependencyTranslator
from .mapper import ResourceMapper
from .models import TerraformModule, TerraformProject

logger = structlog.get_logger(__name__)


class TerraformGenerator:
    """Generates Terraform configurations from graph structures."""

    def __init__(self, graph_connection, archetype_registry=None):
        """Initialize the generator.

        Args:
            graph_connection: Connection to the graph database
            archetype_registry: Registry of archetype templates
        """
        self.graph = graph_connection
        self.mapper = ResourceMapper(archetype_registry)
        self.dependency_translator = DependencyTranslator()
        self.project = None

    def generate_infrastructure(self, graph_id: str) -> TerraformProject:
        """Generate complete Terraform project from graph.

        Args:
            graph_id: ID of the graph to generate from

        Returns:
            Complete Terraform project
        """
        logger.info("Generating Terraform infrastructure", graph_id=graph_id)

        # Fetch graph data
        graph_data = self._fetch_graph_data(graph_id)

        # Create project structure
        self.project = self.create_project_structure(graph_id)

        # Generate main configuration
        self.project.main = self.generate_main_tf(graph_data)

        # Generate modules for each node
        for node in graph_data.get("nodes", []):
            module = self._generate_node_module(node, graph_data)
            if module:
                self.project.modules[node["name"]] = module

        # Generate variables and outputs
        self.project.variables = self.generate_variables(graph_data)
        self.project.outputs = self.generate_outputs(graph_data)

        # Generate backend configuration
        self.project.backend = self.generate_backend_config()

        # Generate version constraints
        self.project.versions = self._generate_versions()

        # Process dependencies from edges
        dependencies = self.dependency_translator.translate_edges_to_dependencies(
            graph_data
        )
        self._apply_dependencies(dependencies)

        logger.info("Terraform generation complete", modules=len(self.project.modules))

        return self.project

    def create_project_structure(
        self, name: str = "solve-generated"
    ) -> TerraformProject:
        """Create the base project structure.

        Args:
            name: Name of the project

        Returns:
            Empty Terraform project
        """
        return TerraformProject(name=name)

    def generate_main_tf(self, graph_data: dict) -> str:
        """Generate the main Terraform configuration.

        Args:
            graph_data: Graph data with nodes and edges

        Returns:
            HCL content for main.tf
        """
        hcl = "# Generated by SOLVE - Graph-to-Terraform Pipeline\n\n"

        # Provider configuration
        hcl += 'provider "google" {\n'
        hcl += "  project = var.gcp_project\n"
        hcl += "  region  = var.gcp_region\n"
        hcl += "}\n\n"

        # Module references for each node
        for node in graph_data.get("nodes", []):
            if node.get("type") in [
                "GCPPrimitive",
                "CloudRun",
                "CloudFunction",
                "PubSub",
                "Firestore",
            ]:
                hcl += f'module "{node["name"]}" {{\n'
                hcl += f'  source = "./modules/{node["name"]}"\n'
                hcl += "  project_id = var.gcp_project\n"
                hcl += "  region = var.gcp_region\n"
                hcl += "  environment = var.environment\n"
                hcl += "}\n\n"

        return hcl

    def generate_variables(self, graph_data: dict) -> str:
        """Generate variables configuration.

        Args:
            graph_data: Graph data

        Returns:
            HCL content for variables.tf
        """
        hcl = "# Project variables\n\n"

        # Standard variables
        hcl += 'variable "gcp_project" {\n'
        hcl += '  description = "GCP project ID"\n'
        hcl += "  type        = string\n"
        hcl += "}\n\n"

        hcl += 'variable "gcp_region" {\n'
        hcl += '  description = "GCP region for resources"\n'
        hcl += "  type        = string\n"
        hcl += '  default     = "us-central1"\n'
        hcl += "}\n\n"

        hcl += 'variable "environment" {\n'
        hcl += '  description = "Deployment environment (dev, staging, prod)"\n'
        hcl += "  type        = string\n"
        hcl += '  default     = "dev"\n'
        hcl += "}\n\n"

        # Add labels variable
        hcl += 'variable "labels" {\n'
        hcl += '  description = "Resource labels"\n'
        hcl += "  type        = map(string)\n"
        hcl += "  default = {\n"
        hcl += '    managed_by = "solve"\n'
        hcl += '    generated  = "terraform"\n'
        hcl += "  }\n"
        hcl += "}\n\n"

        return hcl

    def generate_outputs(self, graph_data: dict) -> str:
        """Generate outputs configuration.

        Args:
            graph_data: Graph data

        Returns:
            HCL content for outputs.tf
        """
        hcl = "# Project outputs\n\n"

        # Output for each module
        for node in graph_data.get("nodes", []):
            if node.get("type") in ["GCPPrimitive", "CloudRun", "CloudFunction"]:
                name = node["name"]
                hcl += f'output "{name}_url" {{\n'
                hcl += f'  description = "URL for {name}"\n'
                hcl += f"  value       = module.{name}.service_url\n"
                hcl += "}\n\n"

                hcl += f'output "{name}_id" {{\n'
                hcl += f'  description = "Resource ID for {name}"\n'
                hcl += f"  value       = module.{name}.resource_id\n"
                hcl += "}\n\n"

        return hcl

    def generate_backend_config(self) -> str:
        """Generate backend configuration for state management.

        Returns:
            HCL content for backend.tf
        """
        hcl = "# Terraform state backend configuration\n\n"
        hcl += "terraform {\n"
        hcl += '  backend "gcs" {\n'
        hcl += "    bucket = var.state_bucket\n"
        hcl += '    prefix = "terraform/state"\n'
        hcl += "  }\n"
        hcl += "}\n"
        return hcl

    def _fetch_graph_data(self, graph_id: str) -> dict:
        """Fetch graph data from the database.

        Args:
            graph_id: ID of the graph

        Returns:
            Graph data with nodes and edges
        """
        try:
            with self.graph.session() as session:
                # Fetch nodes
                nodes_result = session.run(
                    """
                    MATCH (n)
                    WHERE n.graph_id = $graph_id OR n.system_name = $graph_id
                    RETURN n, labels(n) as labels
                """,
                    graph_id=graph_id,
                )

                nodes = []
                for record in nodes_result:
                    node_data = dict(record["n"])
                    node_data["labels"] = record["labels"]
                    node_data["type"] = (
                        record["labels"][0] if record["labels"] else "Unknown"
                    )
                    nodes.append(node_data)

                # Fetch edges
                edges_result = session.run(
                    """
                    MATCH (s)-[r]->(t)
                    WHERE s.graph_id = $graph_id OR s.system_name = $graph_id
                    RETURN s.name as source, t.name as target, type(r) as type,
                           properties(r) as properties
                """,
                    graph_id=graph_id,
                )

                edges = []
                for record in edges_result:
                    edges.append(
                        {
                            "source": record["source"],
                            "target": record["target"],
                            "type": record["type"],
                            "properties": record["properties"] or {},
                        },
                    )

                return {"graph_id": graph_id, "nodes": nodes, "edges": edges}
        except Exception as e:
            logger.error("Failed to fetch graph data", error=str(e))
            # Return sample data for development
            return self._get_sample_graph_data()

    def _generate_node_module(
        self, node: dict, graph_data: dict
    ) -> Optional[TerraformModule]:
        """Generate a Terraform module for a node.

        Args:
            node: Node data
            graph_data: Complete graph data

        Returns:
            Terraform module or None
        """
        node_type = node.get("primitive_type") or node.get("type", "").lower()

        # Skip non-GCP nodes
        if node_type not in [
            "cloud_run",
            "cloudrun",
            "cloud_function",
            "cloudfunction",
            "pubsub",
            "firestore",
            "cloud_storage",
            "cloudstorage",
        ]:
            return None

        module = TerraformModule(name=node["name"])

        # Map node to resources
        resources = self.mapper.node_to_resources(node)
        module.resources = resources

        # Add module variables
        module.variables = {
            "project_id": {"description": "GCP project ID", "type": "string"},
            "region": {"description": "GCP region", "type": "string"},
            "environment": {"description": "Deployment environment", "type": "string"},
        }

        # Add module outputs
        module.outputs = {
            "resource_id": {
                "description": f"ID of {node['name']}",
                "value": f"google_{node_type}_service.{node['name']}.id",
            },
            "service_url": {
                "description": f"URL of {node['name']}",
                "value": f"google_{node_type}_service.{node['name']}.url",
            },
        }

        return module

    def _apply_dependencies(self, dependencies: dict) -> None:
        """Apply dependencies to modules.

        Args:
            dependencies: Dependency mappings
        """
        for source, deps in dependencies.items():
            if source in self.project.modules:
                module = self.project.modules[source]

                # Add depends_on
                if "depends_on" in deps:
                    for resource in module.resources:
                        resource.depends_on.extend(deps["depends_on"])

                # Add environment variables
                if "environment_variables" in deps:
                    for resource in module.resources:
                        if "env" not in resource.properties:
                            resource.properties["env"] = []
                        for key, value in deps["environment_variables"].items():
                            resource.properties["env"].append(
                                {"name": key, "value": value}
                            )

    def _generate_versions(self) -> str:
        """Generate version constraints.

        Returns:
            HCL content for versions.tf
        """
        hcl = "# Terraform and provider version constraints\n\n"
        hcl += "terraform {\n"
        hcl += '  required_version = ">= 1.0"\n\n'
        hcl += "  required_providers {\n"
        hcl += "    google = {\n"
        hcl += '      source  = "hashicorp/google"\n'
        hcl += '      version = "~> 5.0"\n'
        hcl += "    }\n"
        hcl += "    google-beta = {\n"
        hcl += '      source  = "hashicorp/google-beta"\n'
        hcl += '      version = "~> 5.0"\n'
        hcl += "    }\n"
        hcl += "  }\n"
        hcl += "}\n"
        return hcl

    def _get_sample_graph_data(self) -> dict:
        """Get sample graph data for testing.

        Returns:
            Sample graph structure
        """
        return {
            "graph_id": "sample-system",
            "nodes": [
                {
                    "name": "api-service",
                    "type": "CloudRun",
                    "primitive_type": "cloud_run",
                    "image": "gcr.io/project/api:latest",
                    "port": 8080,
                    "memory": "512Mi",
                    "cpu": "1",
                },
                {
                    "name": "auth-function",
                    "type": "CloudFunction",
                    "primitive_type": "cloud_function",
                    "runtime": "python39",
                    "entry_point": "handle_auth",
                },
                {"name": "events-topic", "type": "PubSub", "primitive_type": "pubsub"},
            ],
            "edges": [
                {
                    "source": "api-service",
                    "target": "auth-function",
                    "type": "CALLS",
                    "properties": {},
                },
                {
                    "source": "api-service",
                    "target": "events-topic",
                    "type": "PUBLISHES",
                    "properties": {},
                },
            ],
        }
