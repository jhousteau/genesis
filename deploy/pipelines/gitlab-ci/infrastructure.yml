# GitLab CI/CD Pipeline for Infrastructure Deployment
# Terraform-based infrastructure provisioning on GCP with security and compliance

variables:
  # Terraform configuration
  TF_VERSION: "1.6.0"
  TF_ROOT: "${CI_PROJECT_DIR}"
  TF_ADDRESS: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/terraform/state"
  
  # GCP configuration
  GCLOUD_VERSION: "latest"
  
  # Security tools
  TFSEC_VERSION: "latest"
  CHECKOV_VERSION: "latest"

# Global pipeline settings
image: hashicorp/terraform:${TF_VERSION}

# Cache for Terraform plugins and modules
cache:
  key: "${CI_COMMIT_REF_SLUG}-terraform"
  paths:
    - .terraform/
    - .terraform.lock.hcl

stages:
  - setup
  - validate
  - security
  - plan
  - deploy
  - verify
  - cleanup

# Template for GCP authentication
.gcp_auth: &gcp_auth
  before_script:
    - apk add --no-cache curl python3 py3-pip jq
    - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > ${HOME}/gcp-key.json
    - export GOOGLE_APPLICATION_CREDENTIALS=${HOME}/gcp-key.json
    - curl https://sdk.cloud.google.com | bash > /dev/null
    - export PATH="$PATH:${HOME}/google-cloud-sdk/bin"
    - gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json

# Template for Terraform state configuration
.terraform_state: &terraform_state
  before_script:
    - export TF_HTTP_ADDRESS="${TF_ADDRESS}/${ENVIRONMENT}"
    - export TF_HTTP_LOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
    - export TF_HTTP_UNLOCK_ADDRESS="${TF_HTTP_ADDRESS}/lock"
    - export TF_HTTP_USERNAME="gitlab-ci-token"
    - export TF_HTTP_PASSWORD="${CI_JOB_TOKEN}"
    - export TF_HTTP_RETRY_WAIT_MIN=5

# Environment and workspace determination
setup:
  stage: setup
  image: alpine:latest
  script:
    - |
      echo "üîß Setting up deployment environment..."
      
      # Determine target environment based on branch
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        echo "ENVIRONMENT=prod" >> deploy.env
        echo "WORKSPACE=prod" >> deploy.env
        echo "GCP_PROJECT_ID=${CI_PROJECT_NAME}-prod" >> deploy.env
        echo "AUTO_APPROVE=false" >> deploy.env
      elif [[ "$CI_COMMIT_REF_NAME" == "develop" ]]; then
        echo "ENVIRONMENT=dev" >> deploy.env
        echo "WORKSPACE=dev" >> deploy.env
        echo "GCP_PROJECT_ID=${CI_PROJECT_NAME}-dev" >> deploy.env
        echo "AUTO_APPROVE=true" >> deploy.env
      elif [[ "$CI_COMMIT_REF_NAME" =~ ^release/.* ]]; then
        echo "ENVIRONMENT=stage" >> deploy.env
        echo "WORKSPACE=stage" >> deploy.env
        echo "GCP_PROJECT_ID=${CI_PROJECT_NAME}-stage" >> deploy.env
        echo "AUTO_APPROVE=false" >> deploy.env
      else
        echo "ENVIRONMENT=dev" >> deploy.env
        echo "WORKSPACE=dev" >> deploy.env
        echo "GCP_PROJECT_ID=${CI_PROJECT_NAME}-dev" >> deploy.env
        echo "AUTO_APPROVE=true" >> deploy.env
      fi
      
      # Determine working directory
      if [[ -d "environments/${ENVIRONMENT}" ]]; then
        echo "WORKING_DIR=environments/${ENVIRONMENT}" >> deploy.env
      elif [[ -d "terraform/${ENVIRONMENT}" ]]; then
        echo "WORKING_DIR=terraform/${ENVIRONMENT}" >> deploy.env
      elif [[ -d "terraform" ]]; then
        echo "WORKING_DIR=terraform" >> deploy.env
      else
        echo "WORKING_DIR=." >> deploy.env
      fi
      
      echo "DEPLOYMENT_ID=${CI_COMMIT_SHA:0:8}-$(date +%Y%m%d%H%M%S)" >> deploy.env
      
      echo "üìã Environment configuration:"
      cat deploy.env
  artifacts:
    reports:
      dotenv: deploy.env
    expire_in: 1 hour

# Terraform format and validation
validate:
  stage: validate
  needs: ["setup"]
  script:
    - |
      echo "üìã Validating Terraform configuration..."
      
      # Format check
      echo "Checking Terraform formatting..."
      terraform fmt -check -recursive -diff
      if [[ $? -ne 0 ]]; then
        echo "‚ùå Terraform files are not properly formatted"
        echo "Run 'terraform fmt -recursive' to fix formatting issues"
        exit 1
      fi
      
      # Initialize and validate each environment
      for env_dir in environments/*/; do
        if [[ -f "$env_dir/main.tf" ]]; then
          echo "Validating $env_dir..."
          cd "$env_dir"
          terraform init -backend=false
          terraform validate
          cd "${TF_ROOT}"
        fi
      done
      
      # Validate modules
      for module_dir in modules/*/; do
        if [[ -f "$module_dir/main.tf" ]]; then
          echo "Validating $module_dir..."
          cd "$module_dir"
          terraform init -backend=false
          terraform validate
          cd "${TF_ROOT}"
        fi
      done
      
      echo "‚úÖ Terraform validation completed"
  only:
    changes:
      - "**/*.tf"
      - "**/*.tfvars"
    refs:
      - merge_requests
      - main
      - develop
      - /^release\/.*$/

# Terraform documentation check
docs_check:
  stage: validate
  image: alpine:latest
  needs: ["setup"]
  before_script:
    - apk add --no-cache curl
    - curl -sSLo ./terraform-docs.tar.gz https://terraform-docs.io/dl/v0.16.0/terraform-docs-v0.16.0-linux-amd64.tar.gz
    - tar -xzf terraform-docs.tar.gz
    - chmod +x terraform-docs
  script:
    - |
      echo "üìö Checking Terraform documentation..."
      
      # Check each module has up-to-date documentation
      for module_dir in modules/*/; do
        if [[ -f "$module_dir/main.tf" ]]; then
          echo "Checking documentation for $module_dir..."
          cd "$module_dir"
          if ! ../../terraform-docs markdown table --output-check .; then
            echo "‚ùå Documentation is out of date in $module_dir"
            echo "Run 'terraform-docs markdown table --output-file README.md .' to update"
            exit 1
          fi
          cd "${TF_ROOT}"
        fi
      done
      
      echo "‚úÖ All documentation is up to date"
  only:
    changes:
      - "**/*.tf"
      - "**/README.md"
    refs:
      - merge_requests

# Security scanning with tfsec
security_tfsec:
  stage: security
  image: alpine:latest
  needs: ["setup"]
  before_script:
    - apk add --no-cache curl
    - curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | sh
  script:
    - |
      echo "üîí Running tfsec security scan..."
      
      # Run tfsec with JSON output
      tfsec . --format json --out tfsec-results.json || true
      
      # Parse results and show summary
      if [[ -f "tfsec-results.json" ]]; then
        HIGH_ISSUES=$(cat tfsec-results.json | jq '.results[] | select(.severity=="HIGH") | .rule_id' | wc -l)
        MEDIUM_ISSUES=$(cat tfsec-results.json | jq '.results[] | select(.severity=="MEDIUM") | .rule_id' | wc -l)
        LOW_ISSUES=$(cat tfsec-results.json | jq '.results[] | select(.severity=="LOW") | .rule_id' | wc -l)
        
        echo "üìä Security scan results:"
        echo "  High:   $HIGH_ISSUES"
        echo "  Medium: $MEDIUM_ISSUES"
        echo "  Low:    $LOW_ISSUES"
        
        if [[ $HIGH_ISSUES -gt 0 ]]; then
          echo "‚ùå High severity security issues found"
          cat tfsec-results.json | jq '.results[] | select(.severity=="HIGH")'
          exit 1
        elif [[ $MEDIUM_ISSUES -gt 5 ]]; then
          echo "‚ö†Ô∏è Too many medium severity issues found"
          exit 1
        fi
      fi
  artifacts:
    paths:
      - tfsec-results.json
    reports:
      junit: tfsec-junit.xml
    expire_in: 1 week
  only:
    changes:
      - "**/*.tf"
    refs:
      - merge_requests
      - main
      - develop

# Security scanning with Checkov
security_checkov:
  stage: security
  image: python:3.11-alpine
  needs: ["setup"]
  before_script:
    - pip install checkov
  script:
    - |
      echo "üîí Running Checkov security scan..."
      
      # Run Checkov with JUnit output
      checkov -d . --framework terraform \
        --output cli --output junitxml \
        --output-file-path console,checkov-results.xml \
        --soft-fail || true
      
      echo "‚úÖ Checkov scan completed"
  artifacts:
    paths:
      - checkov-results.xml
    reports:
      junit: checkov-results.xml
    expire_in: 1 week
  only:
    changes:
      - "**/*.tf"
    refs:
      - merge_requests
      - main
      - develop

# Cost estimation with Infracost
cost_estimation:
  stage: security
  image: infracost/infracost:latest
  needs: ["setup"]
  variables:
    INFRACOST_ENABLE_CLOUD: "false"
  script:
    - |
      echo "üí∞ Running infrastructure cost estimation..."
      
      if [[ -n "${INFRACOST_API_KEY}" ]]; then
        # Generate cost estimate
        infracost breakdown --path . \
          --format json \
          --out-file infracost-base.json
        
        # Generate HTML report
        infracost output --path infracost-base.json \
          --format html \
          --out-file infracost-report.html
        
        # Show cost summary
        infracost output --path infracost-base.json \
          --format table
        
        echo "‚úÖ Cost estimation completed"
      else
        echo "‚ö†Ô∏è INFRACOST_API_KEY not set, skipping cost estimation"
      fi
  artifacts:
    paths:
      - infracost-base.json
      - infracost-report.html
    expire_in: 1 week
  only:
    refs:
      - merge_requests
      - main
      - develop

# Terraform plan
plan:
  stage: plan
  needs: ["setup", "validate"]
  <<: *gcp_auth
  <<: *terraform_state
  variables:
    TF_IN_AUTOMATION: "true"
  script:
    - |
      echo "üìã Running Terraform plan..."
      echo "Environment: ${ENVIRONMENT}"
      echo "Workspace: ${WORKSPACE}"
      echo "Working directory: ${WORKING_DIR}"
      echo "Project: ${GCP_PROJECT_ID}"
      
      cd "${WORKING_DIR}"
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Initialize Terraform
      terraform init \
        -backend-config="bucket=${CI_PROJECT_NAME}-tfstate-${ENVIRONMENT}" \
        -backend-config="prefix=terraform/state"
      
      # Select or create workspace
      terraform workspace select ${WORKSPACE} || terraform workspace new ${WORKSPACE}
      
      # Create terraform.tfvars if it doesn't exist
      if [[ ! -f "terraform.tfvars" ]] && [[ -f "terraform.tfvars.example" ]]; then
        cp terraform.tfvars.example terraform.tfvars
        sed -i "s/PROJECT_ID_PLACEHOLDER/${GCP_PROJECT_ID}/g" terraform.tfvars
      fi
      
      # Run terraform plan
      terraform plan \
        -detailed-exitcode \
        -out="tfplan-${DEPLOYMENT_ID}" \
        -var="project_id=${GCP_PROJECT_ID}" \
        -var="environment=${ENVIRONMENT}" \
        -var="deployment_id=${DEPLOYMENT_ID}"
      
      PLAN_EXIT_CODE=$?
      
      # Save plan output for review
      terraform show -no-color "tfplan-${DEPLOYMENT_ID}" > plan-output.txt
      
      if [[ $PLAN_EXIT_CODE -eq 2 ]]; then
        echo "‚úÖ Terraform plan completed with changes"
        echo "HAS_CHANGES=true" >> ../plan-status.env
        
        # Generate plan summary
        CHANGES=$(terraform show -json "tfplan-${DEPLOYMENT_ID}" | jq -r '.resource_changes[] | "\(.change.actions[0]) \(.type) \(.name)"' | sort)
        echo "üìã Planned changes:"
        echo "$CHANGES"
        
      elif [[ $PLAN_EXIT_CODE -eq 0 ]]; then
        echo "‚ÑπÔ∏è Terraform plan completed with no changes"
        echo "HAS_CHANGES=false" >> ../plan-status.env
      else
        echo "‚ùå Terraform plan failed"
        exit 1
      fi
  artifacts:
    paths:
      - "${WORKING_DIR}/tfplan-${DEPLOYMENT_ID}"
      - "${WORKING_DIR}/plan-output.txt"
    reports:
      dotenv: plan-status.env
    expire_in: 1 week
  only:
    changes:
      - "**/*.tf"
      - "**/*.tfvars"
    refs:
      - merge_requests
      - main
      - develop
      - /^release\/.*$/

# Terraform apply (non-production)
apply_dev:
  stage: deploy
  needs: ["setup", "plan"]
  <<: *gcp_auth
  <<: *terraform_state
  variables:
    TF_IN_AUTOMATION: "true"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "develop" && $HAS_CHANGES == "true"'
    - if: '$CI_COMMIT_REF_NAME =~ /^feature\/.*/ && $HAS_CHANGES == "true"'
      when: manual
  script:
    - |
      echo "üöÄ Applying Terraform changes to ${ENVIRONMENT}..."
      
      cd "${WORKING_DIR}"
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Initialize Terraform
      terraform init \
        -backend-config="bucket=${CI_PROJECT_NAME}-tfstate-${ENVIRONMENT}" \
        -backend-config="prefix=terraform/state"
      
      # Select workspace
      terraform workspace select ${WORKSPACE}
      
      # Apply the plan
      terraform apply -auto-approve "tfplan-${DEPLOYMENT_ID}"
      
      # Save outputs
      terraform output -json > terraform-outputs.json
      
      echo "‚úÖ Terraform apply completed successfully"
  artifacts:
    paths:
      - "${WORKING_DIR}/terraform-outputs.json"
    expire_in: 1 month
  environment:
    name: ${ENVIRONMENT}
    action: start

# Terraform apply (production) - requires manual approval
apply_prod:
  stage: deploy
  needs: ["setup", "plan"]
  <<: *gcp_auth
  <<: *terraform_state
  variables:
    TF_IN_AUTOMATION: "true"
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main" && $HAS_CHANGES == "true"'
      when: manual
    - if: '$CI_COMMIT_REF_NAME =~ /^release\/.*/ && $HAS_CHANGES == "true"'
      when: manual
  script:
    - |
      echo "üöÄ Applying Terraform changes to ${ENVIRONMENT}..."
      echo "‚ö†Ô∏è This is a PRODUCTION deployment"
      
      cd "${WORKING_DIR}"
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Initialize Terraform
      terraform init \
        -backend-config="bucket=${CI_PROJECT_NAME}-tfstate-${ENVIRONMENT}" \
        -backend-config="prefix=terraform/state"
      
      # Select workspace
      terraform workspace select ${WORKSPACE}
      
      # Apply the plan
      terraform apply -auto-approve "tfplan-${DEPLOYMENT_ID}"
      
      # Save outputs
      terraform output -json > terraform-outputs.json
      
      # Create deployment record
      cat > deployment-record.json << EOF
      {
        "deployment_id": "${DEPLOYMENT_ID}",
        "environment": "${ENVIRONMENT}",
        "project": "${GCP_PROJECT_ID}",
        "commit": "${CI_COMMIT_SHA}",
        "branch": "${CI_COMMIT_REF_NAME}",
        "pipeline": "${CI_PIPELINE_ID}",
        "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "status": "success"
      }
      EOF
      
      echo "‚úÖ Production deployment completed successfully"
  artifacts:
    paths:
      - "${WORKING_DIR}/terraform-outputs.json"
      - "${WORKING_DIR}/deployment-record.json"
    expire_in: 1 year
  environment:
    name: ${ENVIRONMENT}
    action: start

# Infrastructure verification
verify_infrastructure:
  stage: verify
  needs: ["setup", "apply_dev", "apply_prod"]
  <<: *gcp_auth
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main" || $CI_COMMIT_REF_NAME == "develop"'
    - if: '$CI_COMMIT_REF_NAME =~ /^release\/.*/'
  script:
    - |
      echo "üîç Verifying infrastructure deployment..."
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Check project status
      PROJECT_STATE=$(gcloud projects describe ${GCP_PROJECT_ID} --format="value(lifecycleState)")
      if [[ "$PROJECT_STATE" == "ACTIVE" ]]; then
        echo "‚úÖ Project ${GCP_PROJECT_ID} is active"
      else
        echo "‚ùå Project ${GCP_PROJECT_ID} is not active: $PROJECT_STATE"
        exit 1
      fi
      
      # Check essential APIs
      echo "üîç Checking enabled APIs..."
      REQUIRED_APIS=(
        "compute.googleapis.com"
        "container.googleapis.com"
        "cloudbuild.googleapis.com"
        "storage.googleapis.com"
      )
      
      for api in "${REQUIRED_APIS[@]}"; do
        if gcloud services list --enabled --filter="name:$api" --format="value(name)" | grep -q "$api"; then
          echo "‚úÖ API $api is enabled"
        else
          echo "‚ö†Ô∏è API $api is not enabled"
        fi
      done
      
      # Check resource quotas
      echo "üìä Checking resource quotas..."
      gcloud compute project-info describe --format="table(quotas.metric,quotas.limit,quotas.usage)" \
        --filter="quotas.metric:CPUS OR quotas.metric:DISKS_TOTAL_GB" || true
      
      # Check IAM policies
      echo "üîê Checking IAM security..."
      gcloud projects get-iam-policy ${GCP_PROJECT_ID} --format="table(bindings.role,bindings.members.flatten())" | head -20
      
      # Health check summary
      echo "‚úÖ Infrastructure verification completed"
  only:
    - main
    - develop
    - /^release\/.*$/

# Compliance and governance check
compliance_check:
  stage: verify
  needs: ["setup", "apply_dev", "apply_prod"]
  <<: *gcp_auth
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main"'
    - if: '$ENVIRONMENT == "prod"'
  script:
    - |
      echo "üìã Running compliance checks..."
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Check organization policies
      echo "üèõÔ∏è Organization policies:"
      gcloud resource-manager org-policies list --project=${GCP_PROJECT_ID} \
        --format="table(constraint,listPolicy.allValues)" || echo "No organization policies found"
      
      # Check security recommendations
      echo "üîê Security recommendations:"
      gcloud recommender recommendations list \
        --project=${GCP_PROJECT_ID} \
        --recommender="google.iam.policy.Recommender" \
        --location="global" \
        --format="table(name,description)" \
        --limit=10 || echo "No security recommendations available"
      
      # Check for exposed resources
      echo "üåê Checking for public resources..."
      
      # Check for public storage buckets
      gsutil ls -b gs://* 2>/dev/null | while read bucket; do
        if gsutil iam get "$bucket" | grep -q "allUsers"; then
          echo "‚ö†Ô∏è Public bucket found: $bucket"
        fi
      done || true
      
      # Check for public IP addresses
      gcloud compute instances list --format="table(name,zone,status,networkInterfaces[0].accessConfigs[0].natIP)" \
        --filter="status:RUNNING" || true
      
      echo "‚úÖ Compliance check completed"

# Drift detection (scheduled or manual)
drift_detection:
  stage: verify
  <<: *gcp_auth
  <<: *terraform_state
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
    - if: '$CI_COMMIT_REF_NAME == "main" && $MANUAL_DRIFT_CHECK == "true"'
      when: manual
  script:
    - |
      echo "üîç Checking for infrastructure drift..."
      
      cd "${WORKING_DIR}"
      
      # Configure GCP project
      gcloud config set project ${GCP_PROJECT_ID}
      
      # Initialize Terraform
      terraform init \
        -backend-config="bucket=${CI_PROJECT_NAME}-tfstate-${ENVIRONMENT}" \
        -backend-config="prefix=terraform/state"
      
      # Select workspace
      terraform workspace select ${WORKSPACE}
      
      # Create terraform.tfvars if needed
      if [[ ! -f "terraform.tfvars" ]] && [[ -f "terraform.tfvars.example" ]]; then
        cp terraform.tfvars.example terraform.tfvars
        sed -i "s/PROJECT_ID_PLACEHOLDER/${GCP_PROJECT_ID}/g" terraform.tfvars
      fi
      
      # Run plan to detect drift
      terraform plan \
        -detailed-exitcode \
        -var="project_id=${GCP_PROJECT_ID}" \
        -var="environment=${ENVIRONMENT}" \
        > drift-report.txt
      
      DRIFT_EXIT_CODE=$?
      
      if [[ $DRIFT_EXIT_CODE -eq 2 ]]; then
        echo "‚ö†Ô∏è Configuration drift detected!"
        echo "Drift report:"
        cat drift-report.txt
        
        # Create drift alert (in real implementation, you'd send to monitoring system)
        cat > drift-alert.json << EOF
      {
        "alert": "Infrastructure Drift Detected",
        "environment": "${ENVIRONMENT}",
        "project": "${GCP_PROJECT_ID}",
        "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "severity": "warning",
        "details": "Configuration drift detected in ${ENVIRONMENT} environment"
      }
      EOF
        
        exit 1
      elif [[ $DRIFT_EXIT_CODE -eq 0 ]]; then
        echo "‚úÖ No configuration drift detected"
      else
        echo "‚ùå Error checking for drift"
        exit 1
      fi
  artifacts:
    paths:
      - "${WORKING_DIR}/drift-report.txt"
      - "${WORKING_DIR}/drift-alert.json"
    expire_in: 1 month
    when: always

# Cleanup old plan files
cleanup:
  stage: cleanup
  image: alpine:latest
  script:
    - |
      echo "üßπ Cleaning up old artifacts..."
      # This would typically clean up old plan files, temporary resources, etc.
      echo "Cleanup completed"
  only:
    - main
    - develop
  when: always