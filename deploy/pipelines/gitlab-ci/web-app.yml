# GitLab CI/CD Pipeline for Web Applications
# Supports React, Vue, Angular, and static sites with GCP deployment

variables:
  # Project configuration
  PROJECT_NAME: "${CI_PROJECT_NAME}"
  REGISTRY_REGION: "us-central1"
  
  # Docker configuration
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Node.js configuration
  NODE_VERSION: "18"
  
  # GCP configuration
  GCLOUD_VERSION: "latest"

# Global pipeline settings
image: node:${NODE_VERSION}-alpine

stages:
  - setup
  - validate
  - test
  - security
  - build
  - deploy
  - verify
  - cleanup

# Template for GCP authentication
.gcp_auth: &gcp_auth
  before_script:
    - apk add --no-cache curl python3 py3-pip
    - pip3 install --upgrade google-cloud-storage
    - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > ${HOME}/gcp-key.json
    - export GOOGLE_APPLICATION_CREDENTIALS=${HOME}/gcp-key.json
    - curl https://sdk.cloud.google.com | bash > /dev/null
    - export PATH="$PATH:${HOME}/google-cloud-sdk/bin"
    - gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
    - gcloud config set project ${GCP_PROJECT_ID}

# Environment determination
setup:
  stage: setup
  image: alpine:latest
  script:
    - |
      # Determine target environment
      if [[ "$CI_COMMIT_REF_NAME" == "main" ]]; then
        echo "ENVIRONMENT=prod" >> deploy.env
        echo "GCP_PROJECT_ID=${PROJECT_NAME}-prod" >> deploy.env
      elif [[ "$CI_COMMIT_REF_NAME" == "develop" ]]; then
        echo "ENVIRONMENT=dev" >> deploy.env
        echo "GCP_PROJECT_ID=${PROJECT_NAME}-dev" >> deploy.env
      elif [[ "$CI_COMMIT_REF_NAME" =~ ^release/.* ]]; then
        echo "ENVIRONMENT=stage" >> deploy.env
        echo "GCP_PROJECT_ID=${PROJECT_NAME}-stage" >> deploy.env
      else
        echo "ENVIRONMENT=dev" >> deploy.env
        echo "GCP_PROJECT_ID=${PROJECT_NAME}-dev" >> deploy.env
      fi
      
      # Set build configuration
      echo "BUILD_VERSION=${CI_COMMIT_SHA:0:8}-$(date +%Y%m%d%H%M%S)" >> deploy.env
      echo "SHOULD_DEPLOY=true" >> deploy.env
      
      # Framework detection
      if [[ -f "package.json" ]]; then
        if grep -q "react" package.json; then
          echo "FRAMEWORK=react" >> deploy.env
          echo "BUILD_COMMAND=npm run build" >> deploy.env
          echo "BUILD_OUTPUT=build" >> deploy.env
        elif grep -q "vue" package.json; then
          echo "FRAMEWORK=vue" >> deploy.env
          echo "BUILD_COMMAND=npm run build" >> deploy.env
          echo "BUILD_OUTPUT=dist" >> deploy.env
        elif grep -q "@angular" package.json; then
          echo "FRAMEWORK=angular" >> deploy.env
          echo "BUILD_COMMAND=npm run build --prod" >> deploy.env
          echo "BUILD_OUTPUT=dist" >> deploy.env
        else
          echo "FRAMEWORK=javascript" >> deploy.env
          echo "BUILD_COMMAND=npm run build" >> deploy.env
          echo "BUILD_OUTPUT=dist" >> deploy.env
        fi
      else
        echo "FRAMEWORK=static" >> deploy.env
        echo "BUILD_COMMAND=echo 'No build required'" >> deploy.env
        echo "BUILD_OUTPUT=." >> deploy.env
      fi
      
      cat deploy.env
  artifacts:
    reports:
      dotenv: deploy.env
    expire_in: 1 hour

# Code quality and linting
lint:
  stage: validate
  needs: ["setup"]
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-modules"
    paths:
      - node_modules/
  script:
    - |
      if [[ -f "package.json" ]]; then
        echo "üìã Installing dependencies..."
        npm ci --prefer-offline --no-audit
        
        echo "üîç Running linting..."
        
        # ESLint
        if npm list eslint > /dev/null 2>&1; then
          echo "Running ESLint..."
          npx eslint . --ext .js,.jsx,.ts,.tsx --format junit --output-file eslint-report.xml || true
        fi
        
        # Prettier
        if npm list prettier > /dev/null 2>&1; then
          echo "Running Prettier check..."
          npx prettier --check . || echo "‚ö†Ô∏è Formatting issues found"
        fi
        
        # TypeScript check
        if [[ -f "tsconfig.json" ]]; then
          echo "Running TypeScript check..."
          npx tsc --noEmit || echo "‚ö†Ô∏è TypeScript issues found"
        fi
        
        # Stylelint for CSS/SCSS
        if npm list stylelint > /dev/null 2>&1; then
          echo "Running Stylelint..."
          npx stylelint "**/*.{css,scss,sass}" || echo "‚ö†Ô∏è Style issues found"
        fi
      else
        echo "No package.json found, skipping linting"
      fi
  artifacts:
    reports:
      junit: eslint-report.xml
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Unit and integration tests
test:
  stage: test
  needs: ["setup"]
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-modules"
    paths:
      - node_modules/
    policy: pull
  script:
    - |
      if [[ -f "package.json" ]]; then
        echo "üß™ Running tests..."
        npm ci --prefer-offline --no-audit
        
        # Run tests with coverage
        if npm run test:coverage > /dev/null 2>&1; then
          npm run test:coverage
        elif npm run test > /dev/null 2>&1; then
          npm run test -- --coverage --watchAll=false --ci
        elif npx jest --version > /dev/null 2>&1; then
          npx jest --coverage --ci --watchAll=false --reporters=default --reporters=jest-junit
        else
          echo "No test runner found"
        fi
        
        # Generate test report
        echo "Test completed at $(date)" > test-summary.txt
      else
        echo "No package.json found, skipping tests"
        echo "No tests to run" > test-summary.txt
      fi
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
      - test-summary.txt
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# End-to-end tests
e2e_tests:
  stage: test
  needs: ["setup"]
  image: mcr.microsoft.com/playwright:v1.40.0-focal
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-modules"
    paths:
      - node_modules/
    policy: pull
  script:
    - |
      if [[ -f "package.json" ]] && npm list @playwright/test > /dev/null 2>&1; then
        echo "üé≠ Running E2E tests with Playwright..."
        npm ci --prefer-offline --no-audit
        
        # Install Playwright browsers
        npx playwright install --with-deps
        
        # Start dev server in background
        npm run dev &
        DEV_PID=$!
        
        # Wait for server to be ready
        timeout 60 bash -c 'until curl -f http://localhost:3000 > /dev/null 2>&1; do sleep 2; done' || {
          echo "‚ùå Dev server failed to start"
          exit 1
        }
        
        # Run E2E tests
        npx playwright test --reporter=junit
        
        # Cleanup
        kill $DEV_PID || true
      elif [[ -f "cypress.config.js" ]] || [[ -f "cypress.json" ]]; then
        echo "üå≤ Running E2E tests with Cypress..."
        npm ci --prefer-offline --no-audit
        
        # Start dev server
        npm run dev &
        DEV_PID=$!
        
        # Wait for server
        timeout 60 bash -c 'until curl -f http://localhost:3000 > /dev/null 2>&1; do sleep 2; done'
        
        # Run Cypress tests
        npx cypress run --reporter junit --reporter-options "mochaFile=cypress-results.xml"
        
        kill $DEV_PID || true
      else
        echo "No E2E testing framework found, skipping E2E tests"
      fi
  artifacts:
    reports:
      junit:
        - playwright-report/results.xml
        - cypress-results.xml
    paths:
      - playwright-report/
      - cypress/screenshots/
      - cypress/videos/
    expire_in: 1 week
    when: always
  only:
    - merge_requests
    - main
    - develop

# Security scanning
security_scan:
  stage: security
  needs: ["setup"]
  image: alpine:latest
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-modules"
    paths:
      - node_modules/
    policy: pull
  before_script:
    - apk add --no-cache nodejs npm curl
  script:
    - |
      echo "üîí Running security scans..."
      
      if [[ -f "package.json" ]]; then
        # NPM Audit
        echo "Running npm audit..."
        npm audit --audit-level=high --json > npm-audit.json || true
        
        # Snyk scan (if token available)
        if [[ -n "${SNYK_TOKEN}" ]]; then
          echo "Running Snyk scan..."
          npm install -g snyk
          snyk auth ${SNYK_TOKEN}
          snyk test --json > snyk-report.json || true
          snyk code test --json > snyk-code-report.json || true
        fi
        
        # Check for known vulnerable packages
        echo "Checking for vulnerable dependencies..."
        npm ls --depth=0 | grep -E "(lodash@[^4]|moment@[^2])" && echo "‚ö†Ô∏è Potentially vulnerable packages found" || echo "‚úÖ No known vulnerable packages detected"
      fi
      
      # Git secrets scan
      echo "Checking for exposed secrets..."
      if command -v git > /dev/null; then
        # Check for common secret patterns
        git log --all --full-history --grep="password\|secret\|key\|token" --oneline | head -10 | wc -l > secrets-check.txt
        if [[ $(cat secrets-check.txt) -gt 0 ]]; then
          echo "‚ö†Ô∏è Potential secrets found in commit history"
        fi
      fi
      
      # Dockerfile security scan (if exists)
      if [[ -f "Dockerfile" ]]; then
        echo "Dockerfile found - consider running hadolint for security best practices"
      fi
  artifacts:
    paths:
      - npm-audit.json
      - snyk-report.json
      - snyk-code-report.json
      - secrets-check.txt
    expire_in: 1 week
    when: always
  only:
    - merge_requests
    - main
    - develop

# Build application
build:
  stage: build
  needs: ["setup", "lint", "test"]
  cache:
    key: "${CI_COMMIT_REF_SLUG}-node-modules"
    paths:
      - node_modules/
    policy: pull
  script:
    - |
      echo "üèóÔ∏è Building application..."
      echo "Framework: ${FRAMEWORK}"
      echo "Environment: ${ENVIRONMENT}"
      echo "Build version: ${BUILD_VERSION}"
      
      if [[ "${FRAMEWORK}" != "static" ]]; then
        # Install dependencies
        npm ci --prefer-offline --no-audit
        
        # Set environment variables for build
        export NODE_ENV=production
        export REACT_APP_VERSION=${BUILD_VERSION}
        export VUE_APP_VERSION=${BUILD_VERSION}
        export NG_APP_VERSION=${BUILD_VERSION}
        
        # Framework-specific build optimizations
        case "${FRAMEWORK}" in
          react)
            export GENERATE_SOURCEMAP=false
            export INLINE_RUNTIME_CHUNK=false
            ;;
          vue)
            export VUE_CLI_MODERN_BUILD=true
            ;;
          angular)
            export NG_BUILD_CACHE=.angular/cache
            ;;
        esac
        
        # Run build
        echo "Running: ${BUILD_COMMAND}"
        eval "${BUILD_COMMAND}"
        
        # Verify build output
        if [[ -d "${BUILD_OUTPUT}" ]]; then
          echo "‚úÖ Build completed successfully"
          echo "Build size: $(du -sh ${BUILD_OUTPUT})"
          
          # List generated assets
          find ${BUILD_OUTPUT} -type f -name "*.js" -o -name "*.css" -o -name "*.html" | head -10
        else
          echo "‚ùå Build output directory not found: ${BUILD_OUTPUT}"
          exit 1
        fi
        
        # Bundle analysis (if tools available)
        if [[ -f "${BUILD_OUTPUT}/static/js/"*.js ]] && command -v wc > /dev/null; then
          echo "üìä Bundle analysis:"
          for js_file in ${BUILD_OUTPUT}/static/js/*.js; do
            if [[ -f "$js_file" ]]; then
              echo "  $(basename $js_file): $(wc -c < $js_file) bytes"
            fi
          done
        fi
      else
        echo "Static site - no build required"
      fi
      
      # Create build info
      cat > ${BUILD_OUTPUT}/build-info.json << EOF
      {
        "version": "${BUILD_VERSION}",
        "commit": "${CI_COMMIT_SHA}",
        "branch": "${CI_COMMIT_REF_NAME}",
        "environment": "${ENVIRONMENT}",
        "framework": "${FRAMEWORK}",
        "buildTime": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "pipeline": "${CI_PIPELINE_ID}"
      }
      EOF
  artifacts:
    paths:
      - "${BUILD_OUTPUT}/"
    expire_in: 1 week
  only:
    - merge_requests
    - main
    - develop

# Deploy to Firebase Hosting
deploy_firebase:
  stage: deploy
  needs: ["setup", "build"]
  image: node:${NODE_VERSION}-alpine
  <<: *gcp_auth
  script:
    - |
      echo "üöÄ Deploying to Firebase Hosting..."
      echo "Environment: ${ENVIRONMENT}"
      echo "Project: ${GCP_PROJECT_ID}"
      
      # Install Firebase CLI
      npm install -g firebase-tools
      
      # Configure Firebase
      if [[ ! -f "firebase.json" ]]; then
        echo "Creating firebase.json..."
        cat > firebase.json << EOF
      {
        "hosting": {
          "public": "${BUILD_OUTPUT}",
          "ignore": [
            "firebase.json",
            "**/.*",
            "**/node_modules/**"
          ],
          "rewrites": [
            {
              "source": "**",
              "destination": "/index.html"
            }
          ],
          "headers": [
            {
              "source": "/static/**",
              "headers": [
                {
                  "key": "Cache-Control",
                  "value": "max-age=31536000"
                }
              ]
            }
          ]
        }
      }
      EOF
      fi
      
      # Deploy to Firebase
      firebase use ${GCP_PROJECT_ID}
      firebase deploy --only hosting --project ${GCP_PROJECT_ID}
      
      # Get hosting URL
      HOSTING_URL="https://${GCP_PROJECT_ID}.web.app"
      echo "üåê Deployed to: ${HOSTING_URL}"
      echo "DEPLOYMENT_URL=${HOSTING_URL}" >> deploy-result.env
  artifacts:
    reports:
      dotenv: deploy-result.env
    expire_in: 1 hour
  environment:
    name: ${ENVIRONMENT}
    url: https://${GCP_PROJECT_ID}.web.app
  only:
    - main
    - develop
    - /^release\/.*$/

# Deploy to Cloud Storage with CDN
deploy_gcs:
  stage: deploy
  needs: ["setup", "build"]
  image: google/cloud-sdk:alpine
  rules:
    - if: '$CI_COMMIT_REF_NAME == "main" && $DEPLOYMENT_TARGET == "gcs"'
    - if: '$CI_COMMIT_REF_NAME == "develop" && $DEPLOYMENT_TARGET == "gcs"'
  before_script:
    - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > ${HOME}/gcp-key.json
    - gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
    - gcloud config set project ${GCP_PROJECT_ID}
  script:
    - |
      echo "üöÄ Deploying to Cloud Storage with CDN..."
      
      BUCKET_NAME="${GCP_PROJECT_ID}-web-${ENVIRONMENT}"
      
      # Create bucket if it doesn't exist
      if ! gsutil ls -b gs://${BUCKET_NAME} > /dev/null 2>&1; then
        echo "Creating bucket: ${BUCKET_NAME}"
        gsutil mb -l ${REGISTRY_REGION} gs://${BUCKET_NAME}
        gsutil web set -m index.html -e 404.html gs://${BUCKET_NAME}
      fi
      
      # Sync files to bucket
      echo "Syncing files to bucket..."
      gsutil -m rsync -r -d ${BUILD_OUTPUT}/ gs://${BUCKET_NAME}/
      
      # Set cache control headers
      gsutil -m setmeta -h "Cache-Control:max-age=31536000" gs://${BUCKET_NAME}/static/**
      gsutil -m setmeta -h "Cache-Control:no-cache" gs://${BUCKET_NAME}/index.html
      
      # Make bucket publicly readable
      gsutil iam ch allUsers:objectViewer gs://${BUCKET_NAME}
      
      # Set up load balancer and CDN (if configured)
      BUCKET_URL="https://storage.googleapis.com/${BUCKET_NAME}/index.html"
      echo "üåê Deployed to: ${BUCKET_URL}"
      echo "DEPLOYMENT_URL=${BUCKET_URL}" >> deploy-result.env
  artifacts:
    reports:
      dotenv: deploy-result.env
    expire_in: 1 hour
  environment:
    name: ${ENVIRONMENT}-gcs
    url: https://storage.googleapis.com/${GCP_PROJECT_ID}-web-${ENVIRONMENT}/index.html

# Deploy to Cloud Run (containerized)
deploy_cloudrun:
  stage: deploy
  needs: ["setup", "build"]
  image: google/cloud-sdk:alpine
  services:
    - docker:dind
  rules:
    - if: '$DEPLOYMENT_TARGET == "cloudrun"'
  before_script:
    - apk add --no-cache docker
    - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > ${HOME}/gcp-key.json
    - gcloud auth activate-service-account --key-file ${HOME}/gcp-key.json
    - gcloud config set project ${GCP_PROJECT_ID}
    - gcloud auth configure-docker ${REGISTRY_REGION}-docker.pkg.dev
  script:
    - |
      echo "üöÄ Deploying to Cloud Run..."
      
      # Create Dockerfile if it doesn't exist
      if [[ ! -f "Dockerfile" ]]; then
        echo "Creating Dockerfile for web app..."
        cat > Dockerfile << 'EOF'
      FROM nginx:alpine
      COPY ${BUILD_OUTPUT}/ /usr/share/nginx/html/
      COPY nginx.conf /etc/nginx/nginx.conf
      EXPOSE 8080
      CMD ["nginx", "-g", "daemon off;"]
      EOF
        
        # Create nginx config
        cat > nginx.conf << 'EOF'
      events { worker_connections 1024; }
      http {
        include /etc/nginx/mime.types;
        sendfile on;
        keepalive_timeout 65;
        
        server {
          listen 8080;
          server_name localhost;
          
          location / {
            root /usr/share/nginx/html;
            index index.html;
            try_files $uri $uri/ /index.html;
          }
          
          location /static/ {
            expires 1y;
            add_header Cache-Control "public, immutable";
          }
        }
      }
      EOF
      fi
      
      # Build and push image
      IMAGE_TAG="${BUILD_VERSION}"
      IMAGE_URL="${REGISTRY_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/containers/${PROJECT_NAME}-web"
      
      docker build -t "${IMAGE_URL}:${IMAGE_TAG}" .
      docker push "${IMAGE_URL}:${IMAGE_TAG}"
      
      # Deploy to Cloud Run
      gcloud run deploy "${PROJECT_NAME}-web" \
        --image="${IMAGE_URL}:${IMAGE_TAG}" \
        --region="${REGISTRY_REGION}" \
        --project="${GCP_PROJECT_ID}" \
        --platform=managed \
        --allow-unauthenticated \
        --memory=512Mi \
        --cpu=1 \
        --concurrency=100 \
        --max-instances=10 \
        --set-env-vars="ENV=${ENVIRONMENT},VERSION=${BUILD_VERSION}"
      
      # Get service URL
      SERVICE_URL=$(gcloud run services describe "${PROJECT_NAME}-web" \
        --region="${REGISTRY_REGION}" \
        --project="${GCP_PROJECT_ID}" \
        --format="value(status.url)")
      
      echo "üåê Deployed to: ${SERVICE_URL}"
      echo "DEPLOYMENT_URL=${SERVICE_URL}" >> deploy-result.env
  artifacts:
    reports:
      dotenv: deploy-result.env
    expire_in: 1 hour
  environment:
    name: ${ENVIRONMENT}-cloudrun
    url: $DEPLOYMENT_URL

# Post-deployment verification
verify_deployment:
  stage: verify
  needs: ["deploy_firebase", "deploy_gcs", "deploy_cloudrun"]
  image: alpine:latest
  rules:
    - if: '$CI_PIPELINE_SOURCE != "merge_request_event"'
  before_script:
    - apk add --no-cache curl
  script:
    - |
      echo "üîç Verifying deployment..."
      
      if [[ -n "${DEPLOYMENT_URL}" ]]; then
        echo "Testing deployment at: ${DEPLOYMENT_URL}"
        
        # Health check
        for i in {1..5}; do
          if curl -f "${DEPLOYMENT_URL}" --max-time 10 --silent; then
            echo "‚úÖ Health check passed (attempt $i)"
            break
          else
            echo "‚ö†Ô∏è Health check failed (attempt $i/5)"
            if [[ $i -eq 5 ]]; then
              echo "‚ùå Deployment verification failed"
              exit 1
            fi
            sleep 10
          fi
        done
        
        # Performance check
        RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "${DEPLOYMENT_URL}")
        echo "üìä Response time: ${RESPONSE_TIME}s"
        
        if (( $(echo "${RESPONSE_TIME} > 3.0" | bc -l) )); then
          echo "‚ö†Ô∏è Slow response time detected"
        fi
        
        # Check for build info endpoint
        if curl -f "${DEPLOYMENT_URL}/build-info.json" --silent > /dev/null; then
          echo "‚úÖ Build info endpoint accessible"
          curl -s "${DEPLOYMENT_URL}/build-info.json" | head -5
        fi
        
        echo "‚úÖ Deployment verification completed"
      else
        echo "‚ùå No deployment URL available for verification"
        exit 1
      fi
  only:
    - main
    - develop
    - /^release\/.*$/

# Cleanup old artifacts
cleanup:
  stage: cleanup
  image: alpine:latest
  script:
    - echo "üßπ Cleanup completed"
  only:
    - main
    - develop
  when: always