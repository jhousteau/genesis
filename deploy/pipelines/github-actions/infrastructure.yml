name: Deploy Infrastructure

on:
  push:
    branches: [main, develop]
    paths:
      - 'terraform/**'
      - 'modules/**'
      - 'environments/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches: [main]
    paths:
      - 'terraform/**'
      - 'modules/**'
      - 'environments/**'
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - test
          - stage
          - prod
      action:
        description: 'Terraform action'
        required: false
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy
      auto_approve:
        description: 'Auto-approve apply (use with caution)'
        required: false
        default: false
        type: boolean

env:
  PROJECT_NAME: ${{ vars.PROJECT_NAME }}
  TF_VERSION: ${{ vars.TF_VERSION || '1.6.0' }}

permissions:
  contents: read
  id-token: write
  issues: write
  pull-requests: write
  deployments: write

jobs:
  # Environment and action determination
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      gcp_project: ${{ steps.env.outputs.gcp_project }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
      tf_action: ${{ steps.env.outputs.tf_action }}
      working_directory: ${{ steps.env.outputs.working_directory }}
      backend_config: ${{ steps.env.outputs.backend_config }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment and action
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "tf_action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "tf_action=apply" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "tf_action=apply" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "tf_action=plan" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

          # Set GCP project and working directory
          case "${{ steps.env.outputs.environment }}" in
            dev)
              echo "gcp_project=${{ vars.PROJECT_NAME }}-dev" >> $GITHUB_OUTPUT
              echo "working_directory=environments/dev" >> $GITHUB_OUTPUT
              ;;
            test)
              echo "gcp_project=${{ vars.PROJECT_NAME }}-test" >> $GITHUB_OUTPUT
              echo "working_directory=environments/test" >> $GITHUB_OUTPUT
              ;;
            stage)
              echo "gcp_project=${{ vars.PROJECT_NAME }}-stage" >> $GITHUB_OUTPUT
              echo "working_directory=environments/stage" >> $GITHUB_OUTPUT
              ;;
            prod)
              echo "gcp_project=${{ vars.PROJECT_NAME }}-prod" >> $GITHUB_OUTPUT
              echo "working_directory=environments/prod" >> $GITHUB_OUTPUT
              ;;
          esac

          # Set backend configuration
          echo "backend_config=backend-${{ steps.env.outputs.environment }}.conf" >> $GITHUB_OUTPUT

  # Terraform validation and security checks
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: |
          echo "Checking Terraform formatting..."
          terraform fmt -check -recursive -diff
          if [[ $? -ne 0 ]]; then
            echo "❌ Terraform files are not properly formatted"
            echo "Run 'terraform fmt -recursive' to fix formatting issues"
            exit 1
          fi
          echo "✅ All Terraform files are properly formatted"

      - name: Terraform Validation
        run: |
          echo "Validating Terraform configurations..."
          # Validate each environment
          for env_dir in environments/*/; do
            if [[ -f "$env_dir/main.tf" ]]; then
              echo "Validating $env_dir..."
              cd "$env_dir"
              terraform init -backend=false
              terraform validate
              cd - > /dev/null
            fi
          done

          # Validate modules
          for module_dir in modules/*/; do
            if [[ -f "$module_dir/main.tf" ]]; then
              echo "Validating $module_dir..."
              cd "$module_dir"
              terraform init -backend=false
              terraform validate
              cd - > /dev/null
            fi
          done

      - name: Terraform Security Scan
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          additional_args: --format json --out tfsec-results.json
          soft_fail: true

      - name: Upload TfSec Results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: tfsec-results
          path: tfsec-results.json

      - name: Terraform Documentation Check
        run: |
          echo "Checking Terraform documentation..."
          # Install terraform-docs
          curl -sSLo ./terraform-docs.tar.gz https://terraform-docs.io/dl/v0.16.0/terraform-docs-v0.16.0-linux-amd64.tar.gz
          tar -xzf terraform-docs.tar.gz
          chmod +x terraform-docs

          # Check each module has up-to-date documentation
          for module_dir in modules/*/; do
            if [[ -f "$module_dir/main.tf" ]]; then
              echo "Checking documentation for $module_dir..."
              cd "$module_dir"
              ../../terraform-docs markdown table --output-check .
              cd - > /dev/null
            fi
          done

      - name: Infrastructure Cost Estimation
        if: github.event_name == 'pull_request'
        uses: infracost/infracost-gh-action@v0.16
        env:
          INFRACOST_API_KEY: ${{ secrets.INFRACOST_API_KEY }}
        with:
          path: environments/
          terraform_plan_flags: -var-file="terraform.tfvars.example"

  # Terraform Plan
  plan:
    needs: [setup, validate]
    if: needs.setup.outputs.should_deploy == 'true' || github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    environment: ${{ needs.setup.outputs.environment }}
    outputs:
      plan_file: ${{ steps.plan.outputs.plan_file }}
      has_changes: ${{ steps.plan.outputs.has_changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Google Cloud Auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
          project_id: ${{ needs.setup.outputs.gcp_project }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure Terraform Backend
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          # Create backend configuration
          cat > backend.conf << EOF
          bucket = "${{ vars.PROJECT_NAME }}-tfstate-${{ needs.setup.outputs.environment }}"
          prefix = "terraform/state"
          EOF

          echo "Backend configuration:"
          cat backend.conf

      - name: Terraform Init
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          terraform init -backend-config=backend.conf

      - name: Terraform Plan
        id: plan
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          PLAN_FILE="tfplan-${{ github.sha }}"

          # Create terraform.tfvars if it doesn't exist
          if [[ ! -f "terraform.tfvars" ]]; then
            cp terraform.tfvars.example terraform.tfvars
            # Update project ID in tfvars
            sed -i "s/PROJECT_ID_PLACEHOLDER/${{ needs.setup.outputs.gcp_project }}/g" terraform.tfvars
          fi

          terraform plan \
            -detailed-exitcode \
            -out="$PLAN_FILE" \
            -var="project_id=${{ needs.setup.outputs.gcp_project }}" \
            -var="environment=${{ needs.setup.outputs.environment }}"

          PLAN_EXIT_CODE=$?

          echo "plan_file=${PLAN_FILE}" >> $GITHUB_OUTPUT

          if [[ $PLAN_EXIT_CODE -eq 2 ]]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "✅ Terraform plan completed with changes"
          elif [[ $PLAN_EXIT_CODE -eq 0 ]]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "✅ Terraform plan completed with no changes"
          else
            echo "❌ Terraform plan failed"
            exit 1
          fi

      - name: Upload Plan File
        if: steps.plan.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: ${{ needs.setup.outputs.working_directory }}/${{ steps.plan.outputs.plan_file }}

      - name: Plan Summary
        if: github.event_name == 'pull_request'
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          terraform show -no-color ${{ steps.plan.outputs.plan_file }} > plan_output.txt

          # Create PR comment with plan summary
          cat > pr_comment.md << EOF
          ## Terraform Plan Results for \`${{ needs.setup.outputs.environment }}\`

          <details>
          <summary>Show Plan</summary>

          \`\`\`hcl
          $(cat plan_output.txt)
          \`\`\`

          </details>

          **Plan File:** \`${{ steps.plan.outputs.plan_file }}\`
          **Has Changes:** \`${{ steps.plan.outputs.has_changes }}\`
          EOF

  # Terraform Apply
  apply:
    needs: [setup, plan]
    if: |
      needs.setup.outputs.should_deploy == 'true' &&
      needs.setup.outputs.tf_action == 'apply' &&
      needs.plan.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.setup.outputs.environment }}
      url: ${{ steps.output.outputs.console_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Google Cloud Auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
          project_id: ${{ needs.setup.outputs.gcp_project }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download Plan File
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-${{ needs.setup.outputs.environment }}
          path: ${{ needs.setup.outputs.working_directory }}/

      - name: Configure Terraform Backend
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          cat > backend.conf << EOF
          bucket = "${{ vars.PROJECT_NAME }}-tfstate-${{ needs.setup.outputs.environment }}"
          prefix = "terraform/state"
          EOF

      - name: Terraform Init
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          terraform init -backend-config=backend.conf

      - name: Terraform Apply
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          # Apply the plan file
          if [[ "${{ github.event.inputs.auto_approve }}" == "true" ]] || [[ "${{ github.ref }}" != "refs/heads/main" ]]; then
            terraform apply -auto-approve ${{ needs.plan.outputs.plan_file }}
          else
            echo "❌ Manual approval required for production deployment"
            echo "Re-run workflow with auto_approve=true or run terraform apply manually"
            exit 1
          fi

      - name: Capture Outputs
        id: output
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          # Capture terraform outputs
          terraform output -json > terraform_outputs.json

          # Extract key outputs
          if command -v jq &> /dev/null; then
            PROJECT_ID=$(terraform output -raw project_id 2>/dev/null || echo "")
            CONSOLE_URL="https://console.cloud.google.com/home/dashboard?project=${PROJECT_ID}"

            echo "console_url=${CONSOLE_URL}" >> $GITHUB_OUTPUT
            echo "project_id=${PROJECT_ID}" >> $GITHUB_OUTPUT
          fi

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v3
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}
          path: ${{ needs.setup.outputs.working_directory }}/terraform_outputs.json

  # Terraform Destroy (only on workflow_dispatch with destroy action)
  destroy:
    needs: [setup]
    if: |
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest
    environment:
      name: ${{ needs.setup.outputs.environment }}-destroy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Google Cloud Auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
          project_id: ${{ needs.setup.outputs.gcp_project }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure Terraform Backend
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          cat > backend.conf << EOF
          bucket = "${{ vars.PROJECT_NAME }}-tfstate-${{ needs.setup.outputs.environment }}"
          prefix = "terraform/state"
          EOF

      - name: Terraform Init
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          terraform init -backend-config=backend.conf

      - name: Terraform Destroy
        working-directory: ${{ needs.setup.outputs.working_directory }}
        run: |
          # Create terraform.tfvars if it doesn't exist
          if [[ ! -f "terraform.tfvars" ]]; then
            cp terraform.tfvars.example terraform.tfvars
            sed -i "s/PROJECT_ID_PLACEHOLDER/${{ needs.setup.outputs.gcp_project }}/g" terraform.tfvars
          fi

          terraform destroy \
            -auto-approve \
            -var="project_id=${{ needs.setup.outputs.gcp_project }}" \
            -var="environment=${{ needs.setup.outputs.environment }}"

  # Post-deployment validation
  validate-deployment:
    needs: [setup, apply]
    if: |
      always() &&
      needs.apply.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Setup Google Cloud Auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
          project_id: ${{ needs.setup.outputs.gcp_project }}

      - name: Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Infrastructure Health Check
        run: |
          echo "Running infrastructure health checks..."
          PROJECT_ID="${{ needs.setup.outputs.gcp_project }}"

          # Check project exists and is active
          if gcloud projects describe "$PROJECT_ID" --format="value(lifecycleState)" | grep -q "ACTIVE"; then
            echo "✅ Project $PROJECT_ID is active"
          else
            echo "❌ Project $PROJECT_ID is not active or accessible"
            exit 1
          fi

          # Check essential APIs are enabled
          REQUIRED_APIS=(
            "compute.googleapis.com"
            "container.googleapis.com"
            "cloudbuild.googleapis.com"
            "storage.googleapis.com"
          )

          for api in "${REQUIRED_APIS[@]}"; do
            if gcloud services list --enabled --filter="name:$api" --format="value(name)" --project="$PROJECT_ID" | grep -q "$api"; then
              echo "✅ API $api is enabled"
            else
              echo "⚠️ API $api is not enabled (may be intentional)"
            fi
          done

          # Check basic resource quotas
          echo "📊 Checking resource quotas..."
          gcloud compute project-info describe --project="$PROJECT_ID" --format="table(quotas.metric,quotas.limit,quotas.usage)" --filter="quotas.metric:CPUS" || true

      - name: Compliance Check
        run: |
          echo "Running compliance checks..."
          PROJECT_ID="${{ needs.setup.outputs.gcp_project }}"

          # Check organization policies (if applicable)
          echo "📋 Organization policies:"
          gcloud resource-manager org-policies list --project="$PROJECT_ID" --format="table(constraint,listPolicy.allValues)" || echo "No organization policies found"

          # Check IAM recommendations
          echo "🔐 IAM security recommendations:"
          gcloud recommender recommendations list --project="$PROJECT_ID" --recommender="google.iam.policy.Recommender" --location="global" --format="table(name,description)" || echo "No IAM recommendations available"

      - name: Cost Analysis
        run: |
          echo "💰 Infrastructure cost analysis..."
          # This would integrate with Cloud Billing API in a real environment
          echo "Cost analysis would be performed here in a production setup"
          echo "Consider integrating with Infracost or Cloud Billing API"

  # Drift Detection (runs on schedule)
  drift-detection:
    if: github.event_name == 'schedule' || github.event.inputs.action == 'drift-check'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, stage, prod]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Google Cloud Auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
          project_id: ${{ vars.PROJECT_NAME }}-${{ matrix.environment }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Check for Drift
        working-directory: environments/${{ matrix.environment }}
        run: |
          # Configure backend
          cat > backend.conf << EOF
          bucket = "${{ vars.PROJECT_NAME }}-tfstate-${{ matrix.environment }}"
          prefix = "terraform/state"
          EOF

          terraform init -backend-config=backend.conf

          # Create terraform.tfvars
          if [[ ! -f "terraform.tfvars" ]]; then
            cp terraform.tfvars.example terraform.tfvars
            sed -i "s/PROJECT_ID_PLACEHOLDER/${{ vars.PROJECT_NAME }}-${{ matrix.environment }}/g" terraform.tfvars
          fi

          # Run plan to detect drift
          terraform plan \
            -detailed-exitcode \
            -var="project_id=${{ vars.PROJECT_NAME }}-${{ matrix.environment }}" \
            -var="environment=${{ matrix.environment }}" \
            > drift-report.txt

          PLAN_EXIT_CODE=$?

          if [[ $PLAN_EXIT_CODE -eq 2 ]]; then
            echo "⚠️ Configuration drift detected in ${{ matrix.environment }}"
            echo "Drift Report:"
            cat drift-report.txt
            # In production, you might want to create an issue or alert
          elif [[ $PLAN_EXIT_CODE -eq 0 ]]; then
            echo "✅ No configuration drift detected in ${{ matrix.environment }}"
          else
            echo "❌ Error checking for drift in ${{ matrix.environment }}"
            exit 1
          fi
