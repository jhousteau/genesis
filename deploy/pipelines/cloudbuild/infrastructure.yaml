# Cloud Build configuration for Infrastructure Deployment
# Terraform-based infrastructure provisioning with security scanning and validation

substitutions:
  _TERRAFORM_VERSION: '1.6.0'
  _ENVIRONMENT: 'dev'
  _WORKING_DIR: 'environments/dev'
  _STATE_BUCKET: '${PROJECT_ID}-tfstate'
  _AUTO_APPROVE: 'false'
  _CACHE_BUCKET: '${PROJECT_ID}-build-cache'

options:
  # Build configuration
  machineType: 'E2_HIGHCPU_8'
  diskSizeGb: 100
  logging: CLOUD_LOGGING_ONLY
  
  # Environment variables
  env:
    - 'TF_IN_AUTOMATION=true'
    - 'TF_INPUT=false'
    - 'TF_PLUGIN_CACHE_DIR=/workspace/.terraform.d/plugin-cache'

# Build steps
steps:
  # Step 1: Environment Setup
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'setup-environment'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ”§ Setting up infrastructure deployment environment..."
        
        # Determine environment based on branch
        case "$BRANCH_NAME" in
          main)
            echo "prod" > /workspace/environment.txt
            echo "environments/prod" > /workspace/working_dir.txt
            echo "false" > /workspace/auto_approve.txt
            ;;
          develop)
            echo "dev" > /workspace/environment.txt
            echo "environments/dev" > /workspace/working_dir.txt
            echo "true" > /workspace/auto_approve.txt
            ;;
          release/*)
            echo "stage" > /workspace/environment.txt
            echo "environments/stage" > /workspace/working_dir.txt
            echo "false" > /workspace/auto_approve.txt
            ;;
          *)
            echo "dev" > /workspace/environment.txt
            echo "environments/dev" > /workspace/working_dir.txt
            echo "true" > /workspace/auto_approve.txt
            ;;
        esac
        
        ENVIRONMENT=$(cat /workspace/environment.txt)
        WORKING_DIR=$(cat /workspace/working_dir.txt)
        AUTO_APPROVE=$(cat /workspace/auto_approve.txt)
        
        echo "Environment: $ENVIRONMENT"
        echo "Working Directory: $WORKING_DIR"
        echo "Auto Approve: $AUTO_APPROVE"
        echo "Project: ${PROJECT_ID}"
        echo "Branch: $BRANCH_NAME"
        echo "Commit: $COMMIT_SHA"
        
        # Create deployment metadata
        cat > /workspace/deployment-metadata.json << EOF
        {
          "deploymentId": "${COMMIT_SHA:0:8}-$(date +%Y%m%d%H%M%S)",
          "environment": "$ENVIRONMENT",
          "project": "${PROJECT_ID}",
          "branch": "$BRANCH_NAME",
          "commit": "$COMMIT_SHA",
          "buildId": "$BUILD_ID",
          "workingDir": "$WORKING_DIR",
          "autoApprove": $AUTO_APPROVE,
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        
        # Ensure working directory exists
        if [[ ! -d "$WORKING_DIR" ]]; then
          echo "âŒ Working directory $WORKING_DIR does not exist"
          exit 1
        fi
        
        echo "âœ… Environment setup completed"

  # Step 2: Cache Restoration
  - name: 'gcr.io/cloud-builders/gsutil'
    id: 'restore-cache'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ“¦ Restoring Terraform cache..."
        
        # Create plugin cache directory
        mkdir -p /workspace/.terraform.d/plugin-cache
        
        # Restore Terraform plugin cache
        if gsutil -q stat gs://${_CACHE_BUCKET}/terraform-plugins-cache.tar.gz; then
          echo "Restoring Terraform plugin cache..."
          gsutil cp gs://${_CACHE_BUCKET}/terraform-plugins-cache.tar.gz . || true
          tar -xzf terraform-plugins-cache.tar.gz -C /workspace/.terraform.d/plugin-cache || true
        else
          echo "No Terraform plugin cache found"
        fi
        
        echo "âœ… Cache restoration completed"

  # Step 3: Terraform Format Check
  - name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    id: 'terraform-fmt'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ“‹ Checking Terraform formatting..."
        
        terraform fmt -check -recursive -diff
        if [ $? -ne 0 ]; then
          echo "âŒ Terraform files are not properly formatted"
          echo "Run 'terraform fmt -recursive' to fix formatting issues"
          exit 1
        fi
        
        echo "âœ… All Terraform files are properly formatted"

  # Step 4: Terraform Validation
  - name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    id: 'terraform-validate'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ” Validating Terraform configuration..."
        
        # Validate each environment
        for env_dir in environments/*/; do
          if [ -f "$env_dir/main.tf" ]; then
            echo "Validating $env_dir..."
            cd "$env_dir"
            terraform init -backend=false
            terraform validate
            cd /workspace
          fi
        done
        
        # Validate modules
        for module_dir in modules/*/; do
          if [ -f "$module_dir/main.tf" ]; then
            echo "Validating $module_dir..."
            cd "$module_dir"
            terraform init -backend=false
            terraform validate
            cd /workspace
          fi
        done
        
        echo "âœ… Terraform validation completed"

  # Step 5: Security Scanning with tfsec
  - name: 'alpine:latest'
    id: 'security-tfsec'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ”’ Running tfsec security scan..."
        
        # Install tfsec
        apk add --no-cache curl
        curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | sh
        
        # Run tfsec
        /usr/local/bin/tfsec . --format json --out /workspace/tfsec-results.json || true
        
        # Parse results
        if [ -f "/workspace/tfsec-results.json" ]; then
          HIGH_ISSUES=$(cat /workspace/tfsec-results.json | grep -o '"severity":"HIGH"' | wc -l)
          MEDIUM_ISSUES=$(cat /workspace/tfsec-results.json | grep -o '"severity":"MEDIUM"' | wc -l)
          LOW_ISSUES=$(cat /workspace/tfsec-results.json | grep -o '"severity":"LOW"' | wc -l)
          
          echo "ðŸ“Š Security scan results:"
          echo "  High:   $HIGH_ISSUES"
          echo "  Medium: $MEDIUM_ISSUES"
          echo "  Low:    $LOW_ISSUES"
          
          if [ $HIGH_ISSUES -gt 0 ]; then
            echo "âŒ High severity security issues found"
            exit 1
          elif [ $MEDIUM_ISSUES -gt 5 ]; then
            echo "âš ï¸ Too many medium severity issues found"
            exit 1
          fi
        fi
        
        echo "âœ… Security scan completed"

  # Step 6: Security Scanning with Checkov
  - name: 'python:3.11-alpine'
    id: 'security-checkov'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ”’ Running Checkov security scan..."
        
        # Install Checkov
        pip install checkov
        
        # Run Checkov
        checkov -d . --framework terraform \
          --output cli --output json \
          --output-file-path console,/workspace/checkov-results.json \
          --soft-fail || true
        
        echo "âœ… Checkov scan completed"

  # Step 7: Cost Estimation with Infracost
  - name: 'infracost/infracost:latest'
    id: 'cost-estimation'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ’° Running infrastructure cost estimation..."
        
        # Check if Infracost API key is available
        if [ -n "${_INFRACOST_API_KEY}" ]; then
          export INFRACOST_API_KEY=${_INFRACOST_API_KEY}
          
          WORKING_DIR=$(cat /workspace/working_dir.txt)
          
          # Generate cost estimate
          infracost breakdown --path $WORKING_DIR \
            --format json \
            --out-file /workspace/infracost-base.json
          
          # Generate table output
          infracost output --path /workspace/infracost-base.json \
            --format table
          
          echo "âœ… Cost estimation completed"
        else
          echo "âš ï¸ INFRACOST_API_KEY not set, skipping cost estimation"
        fi

  # Step 8: Terraform Init and Plan
  - name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    id: 'terraform-plan'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        echo "ðŸ“‹ Running Terraform plan..."
        
        WORKING_DIR=$(cat /workspace/working_dir.txt)
        ENVIRONMENT=$(cat /workspace/environment.txt)
        DEPLOYMENT_ID=$(cat /workspace/deployment-metadata.json | grep -o '"deploymentId":"[^"]*"' | cut -d'"' -f4)
        
        echo "Working in: $WORKING_DIR"
        echo "Environment: $ENVIRONMENT"
        echo "Deployment ID: $DEPLOYMENT_ID"
        
        cd $WORKING_DIR
        
        # Initialize Terraform
        terraform init \
          -backend-config="bucket=${_STATE_BUCKET}-$ENVIRONMENT" \
          -backend-config="prefix=terraform/state"
        
        # Create or select workspace
        terraform workspace select $ENVIRONMENT || terraform workspace new $ENVIRONMENT
        
        # Create terraform.tfvars if it doesn't exist
        if [ ! -f "terraform.tfvars" ] && [ -f "terraform.tfvars.example" ]; then
          cp terraform.tfvars.example terraform.tfvars
          sed -i "s/PROJECT_ID_PLACEHOLDER/${PROJECT_ID}/g" terraform.tfvars
        fi
        
        # Run terraform plan
        terraform plan \
          -detailed-exitcode \
          -out="/workspace/tfplan-$DEPLOYMENT_ID" \
          -var="project_id=${PROJECT_ID}" \
          -var="environment=$ENVIRONMENT" \
          -var="deployment_id=$DEPLOYMENT_ID"
        
        PLAN_EXIT_CODE=$?
        
        # Save plan output for review
        terraform show -no-color "/workspace/tfplan-$DEPLOYMENT_ID" > /workspace/plan-output.txt
        
        if [ $PLAN_EXIT_CODE -eq 2 ]; then
          echo "âœ… Terraform plan completed with changes"
          echo "true" > /workspace/has_changes.txt
          
          # Generate plan summary
          terraform show -json "/workspace/tfplan-$DEPLOYMENT_ID" > /workspace/plan.json
          
        elif [ $PLAN_EXIT_CODE -eq 0 ]; then
          echo "â„¹ï¸ Terraform plan completed with no changes"
          echo "false" > /workspace/has_changes.txt
        else
          echo "âŒ Terraform plan failed"
          exit 1
        fi

  # Step 9: Manual Approval Gate (for production)
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'approval-gate'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        AUTO_APPROVE=$(cat /workspace/auto_approve.txt)
        HAS_CHANGES=$(cat /workspace/has_changes.txt)
        ENVIRONMENT=$(cat /workspace/environment.txt)
        
        if [ "$HAS_CHANGES" = "true" ]; then
          if [ "$AUTO_APPROVE" = "false" ]; then
            echo "âš ï¸ Manual approval required for $ENVIRONMENT environment"
            echo "ðŸ“‹ Please review the plan output and approve the deployment"
            echo "Plan summary available in build logs"
            
            # In a real implementation, you might:
            # 1. Send notification to approval team
            # 2. Wait for approval webhook
            # 3. Implement approval logic
            
            echo "âœ… Approval gate passed (simulated)"
          else
            echo "âœ… Auto-approval enabled for $ENVIRONMENT environment"
          fi
        else
          echo "â„¹ï¸ No changes to apply, skipping approval gate"
        fi

  # Step 10: Terraform Apply
  - name: 'hashicorp/terraform:${_TERRAFORM_VERSION}'
    id: 'terraform-apply'
    entrypoint: 'sh'
    args:
      - '-c'
      - |
        HAS_CHANGES=$(cat /workspace/has_changes.txt)
        
        if [ "$HAS_CHANGES" = "true" ]; then
          echo "ðŸš€ Applying Terraform changes..."
          
          WORKING_DIR=$(cat /workspace/working_dir.txt)
          ENVIRONMENT=$(cat /workspace/environment.txt)
          DEPLOYMENT_ID=$(cat /workspace/deployment-metadata.json | grep -o '"deploymentId":"[^"]*"' | cut -d'"' -f4)
          
          cd $WORKING_DIR
          
          # Re-initialize (in case of workspace issues)
          terraform init \
            -backend-config="bucket=${_STATE_BUCKET}-$ENVIRONMENT" \
            -backend-config="prefix=terraform/state"
          
          terraform workspace select $ENVIRONMENT
          
          # Apply the plan
          terraform apply -auto-approve "/workspace/tfplan-$DEPLOYMENT_ID"
          
          # Save outputs
          terraform output -json > /workspace/terraform-outputs.json
          
          echo "âœ… Terraform apply completed successfully"
        else
          echo "â„¹ï¸ No changes to apply, skipping terraform apply"
          echo "{}" > /workspace/terraform-outputs.json
        fi

  # Step 11: Infrastructure Verification
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'verify-infrastructure'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ” Verifying infrastructure deployment..."
        
        ENVIRONMENT=$(cat /workspace/environment.txt)
        
        # Check project status
        PROJECT_STATE=$(gcloud projects describe ${PROJECT_ID} --format="value(lifecycleState)")
        if [ "$PROJECT_STATE" = "ACTIVE" ]; then
          echo "âœ… Project ${PROJECT_ID} is active"
        else
          echo "âŒ Project ${PROJECT_ID} is not active: $PROJECT_STATE"
          exit 1
        fi
        
        # Check essential APIs
        echo "ðŸ” Checking enabled APIs..."
        REQUIRED_APIS="compute.googleapis.com container.googleapis.com cloudbuild.googleapis.com storage.googleapis.com"
        
        for api in $REQUIRED_APIS; do
          if gcloud services list --enabled --filter="name:$api" --format="value(name)" | grep -q "$api"; then
            echo "âœ… API $api is enabled"
          else
            echo "âš ï¸ API $api is not enabled"
          fi
        done
        
        # Check resource quotas
        echo "ðŸ“Š Checking resource quotas..."
        gcloud compute project-info describe --format="table(quotas.metric,quotas.limit,quotas.usage)" \
          --filter="quotas.metric:CPUS OR quotas.metric:DISKS_TOTAL_GB" || true
        
        echo "âœ… Infrastructure verification completed"

  # Step 12: Compliance Check
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'compliance-check'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ“‹ Running compliance checks..."
        
        ENVIRONMENT=$(cat /workspace/environment.txt)
        
        # Check organization policies
        echo "ðŸ›ï¸ Organization policies:"
        gcloud resource-manager org-policies list --project=${PROJECT_ID} \
          --format="table(constraint,listPolicy.allValues)" || echo "No organization policies found"
        
        # Check IAM policies
        echo "ðŸ” IAM policy summary:"
        gcloud projects get-iam-policy ${PROJECT_ID} \
          --format="table(bindings.role,bindings.members.flatten())" | head -20
        
        # Check for public resources
        echo "ðŸŒ Checking for public resources..."
        
        # Check for public storage buckets
        if gsutil ls -p ${PROJECT_ID} 2>/dev/null | head -5 | while read bucket; do
          if gsutil iam get "$bucket" 2>/dev/null | grep -q "allUsers"; then
            echo "âš ï¸ Public bucket found: $bucket"
          fi
        done; then
          echo "Bucket check completed"
        fi
        
        # Check for instances with public IPs
        gcloud compute instances list \
          --format="table(name,zone,status,networkInterfaces[0].accessConfigs[0].natIP)" \
          --filter="status:RUNNING" || true
        
        echo "âœ… Compliance check completed"

  # Step 13: Cache Saving
  - name: 'gcr.io/cloud-builders/gsutil'
    id: 'save-cache'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ’¾ Saving Terraform cache..."
        
        # Save Terraform plugin cache
        if [ -d "/workspace/.terraform.d/plugin-cache" ]; then
          echo "Saving Terraform plugin cache..."
          cd /workspace/.terraform.d/plugin-cache
          tar -czf /workspace/terraform-plugins-cache.tar.gz . || true
          gsutil cp /workspace/terraform-plugins-cache.tar.gz gs://${_CACHE_BUCKET}/ || echo "Failed to save cache"
        fi
        
        echo "âœ… Cache saving completed"

  # Step 14: Deployment Summary and Notification
  - name: 'gcr.io/cloud-builders/gcloud'
    id: 'deployment-summary'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "ðŸ“‹ Infrastructure Deployment Summary"
        echo "===================================="
        
        ENVIRONMENT=$(cat /workspace/environment.txt)
        HAS_CHANGES=$(cat /workspace/has_changes.txt)
        DEPLOYMENT_ID=$(cat /workspace/deployment-metadata.json | grep -o '"deploymentId":"[^"]*"' | cut -d'"' -f4)
        
        echo "Project: ${PROJECT_ID}"
        echo "Environment: $ENVIRONMENT"
        echo "Branch: $BRANCH_NAME"
        echo "Commit: $COMMIT_SHA"
        echo "Build ID: $BUILD_ID"
        echo "Deployment ID: $DEPLOYMENT_ID"
        echo "Has Changes: $HAS_CHANGES"
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        
        # Create final deployment record
        cat > /workspace/deployment-summary.json << EOF
        {
          "project": "${PROJECT_ID}",
          "environment": "$ENVIRONMENT",
          "branch": "$BRANCH_NAME",
          "commit": "$COMMIT_SHA",
          "buildId": "$BUILD_ID",
          "deploymentId": "$DEPLOYMENT_ID",
          "hasChanges": $HAS_CHANGES,
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "status": "success"
        }
        EOF
        
        # Upload deployment record
        gsutil cp /workspace/deployment-summary.json gs://${_CACHE_BUCKET}/deployments/
        
        # Display summary of created resources (if outputs available)
        if [ -f "/workspace/terraform-outputs.json" ] && [ -s "/workspace/terraform-outputs.json" ]; then
          echo ""
          echo "ðŸ“Š Terraform Outputs:"
          cat /workspace/terraform-outputs.json | head -20
        fi
        
        echo ""
        echo "âœ… Infrastructure deployment completed successfully!"

# Timeout configuration
timeout: '3600s'  # 1 hour

# Artifact storage
artifacts:
  objects:
    location: 'gs://${_CACHE_BUCKET}/artifacts/${BUILD_ID}'
    paths:
      - 'deployment-summary.json'
      - 'deployment-metadata.json'
      - 'terraform-outputs.json'
      - 'plan-output.txt'
      - 'tfsec-results.json'
      - 'checkov-results.json'
      - 'infracost-base.json'

# Available secrets (configure in Cloud Console)
availableSecrets:
  secretManager:
    - versionName: projects/${PROJECT_ID}/secrets/infracost-api-key/versions/latest
      env: '_INFRACOST_API_KEY'