#!/usr/bin/env python3
"""
Universal Project Bootstrap CLI
The unified command interface for the Universal Project Platform

Usage:
    bootstrap new <name> [options]         # Create new project
    bootstrap retrofit <path>              # Update existing project
    bootstrap list                         # List all managed projects
    bootstrap validate <project>           # Validate project compliance
    bootstrap registry <action>            # Manage project registry
    bootstrap dev <project>                # Start development environment
    bootstrap deploy <project> [env]       # Deploy project
    bootstrap infra <action> <project>     # Infrastructure operations
    bootstrap logs <project>               # View project logs
    bootstrap health <project>             # Check project health
"""

import argparse
import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import yaml

# Add the setup-project module to the path
setup_project_path = str(Path(__file__).parent.parent / "setup-project")
sys.path.insert(0, setup_project_path)
# Add the lib/python module to the path for intelligence
lib_python_path = str(Path(__file__).parent.parent / "lib" / "python")
sys.path.insert(0, lib_python_path)

import importlib.util

# Import from setup-project module
import sys

spec = importlib.util.spec_from_file_location(
    "setup_project", Path(__file__).parent.parent / "setup-project" / "setup.py"
)
setup_project_module = importlib.util.module_from_spec(spec)
spec.loader.exec_module(setup_project_module)
ProjectSetup = setup_project_module.ProjectSetup
try:
    from whitehorse_core.intelligence import IntelligenceCoordinator
    from whitehorse_core.registry import ProjectRegistry

    INTELLIGENCE_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Intelligence features not available: {e}")
    INTELLIGENCE_AVAILABLE = False


class BootstrapCLI:
    """Unified CLI for the Universal Project Platform"""

    def __init__(self):
        self.bootstrap_root = Path(__file__).parent.parent.resolve()
        self.projects_dir = self.bootstrap_root / "projects"
        self.registry_file = self.projects_dir / "registry.yaml"
        self.setup_project = ProjectSetup()

        # Ensure projects directory exists
        self.projects_dir.mkdir(exist_ok=True)

    def load_registry(self) -> Dict[str, Any]:
        """Load the project registry"""
        if not self.registry_file.exists():
            return self.create_default_registry()

        try:
            with open(self.registry_file, "r") as f:
                return yaml.safe_load(f) or {}
        except Exception as e:
            print(f"Error loading registry: {e}")
            return self.create_default_registry()

    def save_registry(self, registry: Dict[str, Any]):
        """Save the project registry"""
        with open(self.registry_file, "w") as f:
            yaml.dump(registry, f, default_flow_style=False, sort_keys=False)

    def create_default_registry(self) -> Dict[str, Any]:
        """Create a default registry structure"""
        from datetime import datetime

        registry = {
            "global": {
                "organization": "whitehorse",
                "default_region": "us-central1",
                "plumbing_version": "2.0.0",
                "bootstrap_version": "1.0.0",
                "registry_version": "2.0.0",
                "last_updated": datetime.now().isoformat() + "Z",
                "standards": {
                    "compliance_level": "enhanced",
                    "security_baseline": "high",
                    "monitoring_required": True,
                    "backup_required": True,
                },
                "templates": {
                    "current_version": "2.0.0",
                    "available_types": [
                        "api",
                        "web-app",
                        "cli",
                        "library",
                        "infrastructure",
                    ],
                    "supported_languages": [
                        "python",
                        "javascript",
                        "go",
                        "rust",
                        "java",
                    ],
                },
                "deployment": {
                    "default_strategy": "canary",
                    "approval_required_envs": ["prod", "stage"],
                    "auto_deploy_envs": ["dev"],
                },
            },
            "projects": {},
        }
        self.save_registry(registry)
        return registry

    def cmd_new(self, args):
        """Create a new project"""
        print(f"üöÄ Creating new project: {args.name}")

        # Determine project path
        if args.path:
            project_path = Path(args.path).resolve()
        else:
            # Default to sibling of bootstrapper
            project_path = self.bootstrap_root.parent / args.name

        project_path.mkdir(parents=True, exist_ok=True)

        # Initialize with setup-project
        old_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            setup = ProjectSetup(str(project_path))
            setup.init_project(
                project_name=args.name,
                project_type=args.type,
                language=args.language,
                cloud_provider=args.cloud,
            )
        finally:
            os.chdir(old_cwd)

        # Register in project registry
        registry = self.load_registry()
        registry["projects"][args.name] = {
            "path": str(project_path),
            "type": args.type,
            "language": args.language,
            "cloud_provider": args.cloud,
            "team": args.team or "unknown",
            "criticality": args.criticality or "medium",
            "environments": {
                "dev": {
                    "gcp_project": f"{args.name}-dev",
                    "gcloud_home": f"~/.gcloud/{args.name}-dev",
                },
                "test": {
                    "gcp_project": f"{args.name}-test",
                    "gcloud_home": f"~/.gcloud/{args.name}-test",
                },
                "prod": {
                    "gcp_project": f"{args.name}-prod",
                    "gcloud_home": f"~/.gcloud/{args.name}-prod",
                    "approval_required": True,
                },
            },
        }
        self.save_registry(registry)

        print(f"‚úÖ Project '{args.name}' created at {project_path}")
        print(f"üìã Registered in project registry")

        if args.git:
            print("üîß Initializing Git repository...")
            subprocess.run(["git", "init"], cwd=project_path, check=True)
            subprocess.run(["git", "add", "."], cwd=project_path, check=True)

            # Use smart-commit if available, otherwise standard commit for initial setup
            smart_commit_path = project_path / "scripts" / "smart-commit.sh"
            if smart_commit_path.exists():
                print("üìù Creating initial commit with smart-commit...")
                # For initial setup, we'll make an exception and use direct git commit
                # since smart-commit may require setup that isn't complete yet
                subprocess.run(
                    [
                        "git",
                        "commit",
                        "-m",
                        "feat: initial project setup\n\nBootstrapped with Universal Project Platform",
                    ],
                    cwd=project_path,
                    check=True,
                )
            else:
                subprocess.run(
                    ["git", "commit", "-m", "feat: initial project setup"],
                    cwd=project_path,
                    check=True,
                )

    def cmd_retrofit(self, args):
        """Retrofit an existing project with bootstrapper standards"""
        project_path = Path(args.path).resolve()

        if not project_path.exists():
            print(f"‚ùå Project path does not exist: {project_path}")
            return 1

        print(f"üîß Retrofitting project at: {project_path}")

        # Detect project characteristics
        old_cwd = os.getcwd()
        try:
            os.chdir(project_path)
            setup = ProjectSetup(str(project_path))
            detected = setup.detect_project_type()

            print(f"üìä Detected characteristics:")
            for key, value in detected.items():
                print(f"   {key}: {value}")

            # Determine project name from directory
            project_name = project_path.name

            # Apply missing components
            if not (project_path / ".project-config.yaml").exists():
                print("üì¶ Initializing project configuration...")
                setup.init_project(
                    project_name=project_name,
                    project_type=args.type or "api",
                    language=detected.get("language", "auto"),
                    cloud_provider="gcp",
                )
            else:
                print("üìà Upgrading existing project...")
                setup.upgrade()

            # Register if not already registered
            registry = self.load_registry()
            if project_name not in registry["projects"]:
                registry["projects"][project_name] = {
                    "path": str(project_path),
                    "type": args.type or "api",
                    "language": detected.get("language", "unknown"),
                    "cloud_provider": "gcp",
                    "team": "unknown",
                    "criticality": "medium",
                    "retrofitted": True,
                    "environments": {
                        "dev": {"gcp_project": f"{project_name}-dev"},
                        "prod": {"gcp_project": f"{project_name}-prod"},
                    },
                }
                self.save_registry(registry)
                print(f"üìã Registered '{project_name}' in project registry")

        finally:
            os.chdir(old_cwd)

        print("‚úÖ Retrofit complete!")

    def cmd_list(self, args):
        """List all managed projects"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if not projects:
            print("üìù No projects found in registry")
            return

        print("üìã Managed Projects:")
        print("=" * 80)

        for name, config in projects.items():
            path = config.get("path", "unknown")
            type_info = config.get("type", "unknown")
            language = config.get("language", "unknown")
            team = config.get("team", "unknown")
            criticality = config.get("criticality", "medium")

            # Check if project exists
            exists = "‚úÖ" if Path(path).exists() else "‚ùå"

            print(f"{exists} {name}")
            print(f"   Type: {type_info} | Language: {language} | Team: {team}")
            print(f"   Path: {path}")
            print(f"   Criticality: {criticality}")

            # Show environments
            envs = config.get("environments", {})
            if envs:
                env_list = ", ".join(envs.keys())
                print(f"   Environments: {env_list}")
            print()

    def cmd_validate(self, args):
        """Validate project compliance"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project == "all":
            # Validate all projects
            for project_name in projects.keys():
                print(f"üîç Validating {project_name}...")
                self._validate_single_project(project_name, projects[project_name])
                print()
        else:
            # Validate specific project
            if args.project not in projects:
                print(f"‚ùå Project '{args.project}' not found in registry")
                return 1

            self._validate_single_project(args.project, projects[args.project])

    def _validate_single_project(self, name: str, config: Dict[str, Any]):
        """Validate a single project"""
        project_path = Path(config["path"])

        if not project_path.exists():
            print(f"‚ùå {name}: Project path does not exist")
            return

        # Run validation script if it exists
        validation_script = project_path / "scripts" / "validate-compliance.sh"
        if validation_script.exists():
            print(f"üîç Running compliance validation for {name}...")
            result = subprocess.run(
                [str(validation_script)],
                cwd=project_path,
                capture_output=True,
                text=True,
            )

            if result.returncode == 0:
                print(f"‚úÖ {name}: Validation passed")
            else:
                print(f"‚ö†Ô∏è  {name}: Validation issues found")
                if result.stdout:
                    print(result.stdout)
        else:
            print(f"‚ö†Ô∏è  {name}: No validation script found")

    def cmd_registry(self, args):
        """Manage project registry"""
        actions = {
            "validate": self._validate_registry,
            "update": self._update_registry,
            "show": self._show_registry,
            "clean": self._clean_registry,
            "backup": self._backup_registry,
            "restore": self._restore_registry,
            "stats": self._registry_stats,
            "export": self._export_registry,
        }

        action_func = actions.get(args.action)
        if action_func:
            return action_func(args) or 0
        else:
            print(f"‚ùå Unknown registry action: {args.action}")
            print(f"Available actions: {', '.join(actions.keys())}")
            return 1

    def _validate_registry(self, args=None):
        """Validate the project registry"""
        print("üîç Validating project registry...")
        registry = self.load_registry()

        # Check global settings
        global_config = registry.get("global", {})
        required_global = ["organization", "default_region", "plumbing_version"]

        for key in required_global:
            if key not in global_config:
                print(f"‚ö†Ô∏è  Missing global setting: {key}")

        # Check each project
        projects = registry.get("projects", {})
        for name, config in projects.items():
            project_path = Path(config.get("path", ""))

            if not project_path.exists():
                print(f"‚ö†Ô∏è  {name}: Project path does not exist: {project_path}")

            required_fields = ["type", "language", "environments"]
            for field in required_fields:
                if field not in config:
                    print(f"‚ö†Ô∏è  {name}: Missing field: {field}")

        print("‚úÖ Registry validation complete")

    def _update_registry(self, args=None):
        """Update the project registry"""
        print("üìà Updating project registry...")
        registry = self.load_registry()

        # Auto-discover projects
        parent_dir = self.bootstrap_root.parent
        for path in parent_dir.iterdir():
            if not path.is_dir() or path.name.startswith("."):
                continue

            if path.name == "bootstrapper":
                continue

            # Check if it's a project directory
            if (path / ".project-config.yaml").exists() or (path / ".git").exists():
                project_name = path.name

                if project_name not in registry["projects"]:
                    print(f"üì¶ Discovered new project: {project_name}")

                    # Try to detect project type
                    project_type = "unknown"
                    language = "unknown"

                    if (path / "package.json").exists():
                        language = "javascript"
                        project_type = "web-app"
                    elif (path / "pyproject.toml").exists() or (
                        path / "requirements.txt"
                    ).exists():
                        language = "python"
                        project_type = "api"
                    elif (path / "go.mod").exists():
                        language = "go"
                        project_type = "api"

                    registry["projects"][project_name] = {
                        "path": str(path),
                        "type": project_type,
                        "language": language,
                        "cloud_provider": "gcp",
                        "team": "unknown",
                        "criticality": "medium",
                        "auto_discovered": True,
                        "environments": {
                            "dev": {"gcp_project": f"{project_name}-dev"},
                            "prod": {"gcp_project": f"{project_name}-prod"},
                        },
                    }

        self.save_registry(registry)
        print("‚úÖ Registry update complete")

    def _show_registry(self, args=None):
        """Show the raw registry content"""
        registry = self.load_registry()
        print("üìã Project Registry:")
        print("=" * 50)
        print(yaml.dump(registry, default_flow_style=False))

    def _clean_registry(self, args=None):
        """Remove projects that no longer exist"""
        print("üßπ Cleaning project registry...")
        registry = self.load_registry()
        projects = registry.get("projects", {})

        cleaned_projects = {}
        removed_count = 0

        for name, config in projects.items():
            project_path = Path(config.get("path", ""))
            if project_path.exists():
                cleaned_projects[name] = config
            else:
                print(f"   üóëÔ∏è  Removing missing project: {name} ({project_path})")
                removed_count += 1

        registry["projects"] = cleaned_projects
        registry["global"]["last_updated"] = datetime.now().isoformat() + "Z"
        self.save_registry(registry)

        print(f"‚úÖ Cleaned registry: removed {removed_count} missing projects")

    def _backup_registry(self, args=None):
        """Create a backup of the registry"""
        import shutil
        from datetime import datetime

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = self.projects_dir / f"registry.yaml.backup.{timestamp}"

        shutil.copy2(self.registry_file, backup_file)
        print(f"üíæ Registry backed up to: {backup_file}")

    def _restore_registry(self, args):
        """Restore registry from backup"""
        import shutil

        if not hasattr(args, "backup_file") or not args.backup_file:
            # List available backups
            backups = list(self.projects_dir.glob("registry.yaml.backup.*"))
            if not backups:
                print("‚ùå No backup files found")
                return 1

            print("üì¶ Available backups:")
            for i, backup in enumerate(backups, 1):
                print(f"  {i}. {backup.name}")

            try:
                choice = input("\nEnter backup number to restore (or 'q' to quit): ")
                if choice.lower() == "q":
                    return 0

                backup_file = backups[int(choice) - 1]
            except (ValueError, IndexError):
                print("‚ùå Invalid selection")
                return 1
        else:
            backup_file = Path(args.backup_file)

        if not backup_file.exists():
            print(f"‚ùå Backup file not found: {backup_file}")
            return 1

        # Create current backup before restore
        self._backup_registry()

        # Restore
        shutil.copy2(backup_file, self.registry_file)
        print(f"‚úÖ Registry restored from: {backup_file}")

    def _registry_stats(self, args=None):
        """Show registry statistics"""
        print("üìä Registry Statistics:")
        print("=" * 50)

        registry = self.load_registry()
        projects = registry.get("projects", {})
        global_config = registry.get("global", {})

        # Basic counts
        total_projects = len(projects)
        print(f"Total Projects: {total_projects}")

        # By type
        type_counts = {}
        for config in projects.values():
            project_type = config.get("type", "unknown")
            type_counts[project_type] = type_counts.get(project_type, 0) + 1

        print("\nBy Type:")
        for ptype, count in sorted(type_counts.items()):
            print(f"  {ptype}: {count}")

        # By language
        lang_counts = {}
        for config in projects.values():
            language = config.get("language", "unknown")
            lang_counts[language] = lang_counts.get(language, 0) + 1

        print("\nBy Language:")
        for lang, count in sorted(lang_counts.items()):
            print(f"  {lang}: {count}")

        # Health status
        healthy = missing = attention_needed = 0
        for config in projects.values():
            path = Path(config.get("path", ""))
            if not path.exists():
                missing += 1
            else:
                # Quick health check
                has_config = (path / ".project-config.yaml").exists()
                has_git = (path / ".git").exists()
                has_readme = (path / "README.md").exists()

                health_score = sum([has_config, has_git, has_readme])
                if health_score >= 2:
                    healthy += 1
                else:
                    attention_needed += 1

        print("\nHealth Status:")
        print(f"  Healthy: {healthy}")
        print(f"  Needs Attention: {attention_needed}")
        print(f"  Missing: {missing}")

        # Global settings
        print(f"\nGlobal Settings:")
        print(f"  Organization: {global_config.get('organization', 'unknown')}")
        print(f"  Registry Version: {global_config.get('registry_version', 'unknown')}")
        print(f"  Last Updated: {global_config.get('last_updated', 'unknown')}")

    def _export_registry(self, args):
        """Export registry in different formats"""
        registry = self.load_registry()

        if not hasattr(args, "format"):
            export_format = "yaml"
        else:
            export_format = args.format

        if not hasattr(args, "output"):
            output_file = self.projects_dir / f"registry_export.{export_format}"
        else:
            output_file = Path(args.output)

        if export_format == "json":
            import json

            with open(output_file, "w") as f:
                json.dump(registry, f, indent=2, default=str)
        elif export_format == "csv":
            import csv

            projects = registry.get("projects", {})

            with open(output_file, "w", newline="") as f:
                writer = csv.writer(f)
                writer.writerow(
                    ["name", "path", "type", "language", "team", "criticality"]
                )

                for name, config in projects.items():
                    writer.writerow(
                        [
                            name,
                            config.get("path", ""),
                            config.get("type", "unknown"),
                            config.get("language", "unknown"),
                            config.get("team", "unknown"),
                            config.get("criticality", "medium"),
                        ]
                    )
        else:  # yaml (default)
            with open(output_file, "w") as f:
                yaml.dump(registry, f, default_flow_style=False)

        print(f"üì§ Registry exported to: {output_file}")

    def cmd_deploy(self, args):
        """Deploy a project"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project not in projects:
            print(f"‚ùå Project '{args.project}' not found in registry")
            return 1

        config = projects[args.project]
        project_path = Path(config["path"])

        if not project_path.exists():
            print(f"‚ùå Project path does not exist: {project_path}")
            return 1

        environment = args.environment or "dev"
        print(f"üöÄ Deploying {args.project} to {environment}...")

        # Check if deploy script exists
        deploy_script = project_path / "scripts" / "deploy.sh"
        if deploy_script.exists():
            env = os.environ.copy()
            env["DEPLOY_ENV"] = environment

            result = subprocess.run(
                [str(deploy_script), environment], cwd=project_path, env=env
            )

            if result.returncode == 0:
                print(f"‚úÖ Deployment to {environment} successful")
            else:
                print(f"‚ùå Deployment to {environment} failed")
                return result.returncode
        else:
            print(f"‚ö†Ô∏è  No deploy script found at {deploy_script}")
            return 1

    def cmd_infra(self, args):
        """Infrastructure operations"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project not in projects:
            print(f"‚ùå Project '{args.project}' not found in registry")
            return 1

        config = projects[args.project]
        project_path = Path(config["path"])

        if not project_path.exists():
            print(f"‚ùå Project path does not exist: {project_path}")
            return 1

        print(f"üèóÔ∏è  Infrastructure {args.action} for {args.project}...")

        # Look for infrastructure directory in project or use bootstrapper modules
        infra_dir = project_path / "infrastructure"
        if not infra_dir.exists():
            infra_dir = self.bootstrap_root / "modules"

        if not infra_dir.exists():
            print(f"‚ùå No infrastructure configuration found")
            return 1

        # Run terraform command
        env = os.environ.copy()
        env["TF_VAR_project_name"] = args.project

        commands = {
            "init": ["terraform", "init"],
            "plan": ["terraform", "plan"],
            "apply": ["terraform", "apply"],
            "destroy": ["terraform", "destroy"],
            "validate": ["terraform", "validate"],
            "fmt": ["terraform", "fmt"],
            "cost": ["terraform", "plan", "-out=plan.out"],
        }

        if args.action not in commands:
            print(f"‚ùå Unknown infrastructure action: {args.action}")
            return 1

        try:
            result = subprocess.run(
                commands[args.action], cwd=infra_dir, env=env, check=True
            )

            # Handle cost estimation
            if args.action == "cost" and result.returncode == 0:
                try:
                    subprocess.run(
                        ["terraform", "show", "-json", "plan.out"],
                        cwd=infra_dir,
                        check=True,
                    )
                    print("üí∞ Cost estimation completed. Review the plan output above.")
                except subprocess.CalledProcessError:
                    print("‚ö†Ô∏è  Could not generate cost estimation")

            print(f"‚úÖ Infrastructure {args.action} completed successfully")
            return 0

        except subprocess.CalledProcessError as e:
            print(
                f"‚ùå Infrastructure {args.action} failed with exit code {e.returncode}"
            )
            return e.returncode
        except FileNotFoundError:
            print(f"‚ùå Terraform not found. Please install Terraform.")
            return 1

    def cmd_intelligence(self, args):
        """Intelligence layer operations"""
        if not INTELLIGENCE_AVAILABLE:
            print(
                "‚ùå Intelligence features are not available. Please check the installation."
            )
            return 1

        if not args.intelligence_action:
            print(
                "‚ùå Please specify an intelligence action. Use 'bootstrap intelligence --help' for options."
            )
            return 1

        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project not in projects:
            print(f"‚ùå Project '{args.project}' not found in registry")
            return 1

        print(f"üß† Running intelligence analysis for {args.project}...")

        try:
            project_registry = ProjectRegistry()
            intelligence = IntelligenceCoordinator(project_registry)

            if args.intelligence_action == "autofix":
                return self._handle_autofix(intelligence, args)
            elif args.intelligence_action == "optimize":
                return self._handle_optimization(intelligence, args)
            elif args.intelligence_action == "predict":
                return self._handle_predictions(intelligence, args)
            elif args.intelligence_action == "recommend":
                return self._handle_recommendations(intelligence, args)
            elif args.intelligence_action == "analyze":
                return self._handle_full_analysis(intelligence, args)
            elif args.intelligence_action == "config":
                return self._handle_intelligence_config(intelligence, args)
            else:
                print(f"‚ùå Unknown intelligence action: {args.intelligence_action}")
                return 1

        except Exception as e:
            print(f"‚ùå Intelligence operation failed: {e}")
            return 1

    def _handle_autofix(self, intelligence: "IntelligenceCoordinator", args):
        """Handle auto-fix command"""
        print(f"üîß Running auto-fix analysis for {args.project}...")

        result = intelligence.run_auto_fix(args.project)

        if result["status"] == "success":
            print("‚úÖ Auto-fix analysis completed successfully")

            if "report" in result and result["report"]:
                report = result["report"]
                total_issues = report.get("total_issues", 0)
                auto_fixable = report.get("auto_fixable_count", 0)

                print(f"üìä Found {total_issues} issues, {auto_fixable} auto-fixable")

                if auto_fixable > 0 and args.apply:
                    print("üî® Applying automatic fixes...")
                    # The auto-fix would have already been applied by the engine
                elif auto_fixable > 0:
                    print(
                        f"üí° Run with --apply to automatically fix {auto_fixable} issues"
                    )

            if result.get("stdout"):
                print("\n" + result["stdout"])

        elif result["status"] == "disabled":
            print("‚ö†Ô∏è  Auto-fix is disabled for this project")
            print("üí° Use 'bootstrap intelligence config' to enable features")
        else:
            print(f"‚ùå Auto-fix failed: {result.get('message', 'Unknown error')}")
            if result.get("stderr"):
                print(f"Error details: {result['stderr']}")
            return 1

        return 0

    def _handle_optimization(self, intelligence: "IntelligenceCoordinator", args):
        """Handle optimization analysis command"""
        print(f"‚ö° Running optimization analysis for {args.project}...")

        result = intelligence.run_optimization_analysis(args.project)

        if result["status"] == "success":
            print("‚úÖ Optimization analysis completed successfully")

            if "report" in result and result["report"]:
                report = result["report"]
                total_recommendations = report.get("total_recommendations", 0)
                summary = report.get("summary", {})

                print(f"üìä Found {total_recommendations} optimization opportunities")
                print(f"   Cost optimizations: {summary.get('cost_optimizations', 0)}")
                print(
                    f"   Performance optimizations: {summary.get('performance_optimizations', 0)}"
                )
                print(
                    f"   Resource optimizations: {summary.get('resource_optimizations', 0)}"
                )
                print(
                    f"   High priority items: {summary.get('high_priority_items', 0)}"
                )

            if result.get("stdout"):
                print("\n" + result["stdout"])

        elif result["status"] == "disabled":
            print("‚ö†Ô∏è  Optimization analysis is disabled for this project")
            print("üí° Use 'bootstrap intelligence config' to enable features")
        else:
            print(
                f"‚ùå Optimization analysis failed: {result.get('message', 'Unknown error')}"
            )
            return 1

        return 0

    def _handle_predictions(self, intelligence: "IntelligenceCoordinator", args):
        """Handle predictions analysis command"""
        print(f"üîÆ Running predictions analysis for {args.project}...")

        result = intelligence.run_predictions_analysis(args.project)

        if result["status"] == "success":
            print("‚úÖ Predictions analysis completed successfully")

            if "report" in result and result["report"]:
                report = result["report"]
                total_predictions = report.get("total_predictions", 0)
                summary = report.get("summary", {})

                print(f"üìä Generated {total_predictions} predictions")
                print(
                    f"   Failure predictions: {summary.get('failure_predictions', 0)}"
                )
                print(
                    f"   Capacity predictions: {summary.get('capacity_predictions', 0)}"
                )
                print(f"   Cost predictions: {summary.get('cost_predictions', 0)}")
                print(
                    f"   Immediate attention needed: {summary.get('immediate_attention_needed', 0)}"
                )

            if result.get("stdout"):
                print("\n" + result["stdout"])

        elif result["status"] == "disabled":
            print("‚ö†Ô∏è  Predictions analysis is disabled for this project")
            print("üí° Use 'bootstrap intelligence config' to enable features")
        else:
            print(
                f"‚ùå Predictions analysis failed: {result.get('message', 'Unknown error')}"
            )
            return 1

        return 0

    def _handle_recommendations(self, intelligence: "IntelligenceCoordinator", args):
        """Handle recommendations analysis command"""
        print(f"üí° Running recommendations analysis for {args.project}...")

        result = intelligence.run_recommendations_analysis(args.project)

        if result["status"] == "success":
            print("‚úÖ Recommendations analysis completed successfully")

            if "report" in result and result["report"]:
                report = result["report"]
                total_recommendations = report.get("total_recommendations", 0)
                summary = report.get("summary", {})

                print(f"üìä Generated {total_recommendations} recommendations")
                print(
                    f"   Architecture: {summary.get('architecture_recommendations', 0)}"
                )
                print(f"   Security: {summary.get('security_recommendations', 0)}")
                print(
                    f"   Performance: {summary.get('performance_recommendations', 0)}"
                )
                print(
                    f"   Maintainability: {summary.get('maintainability_recommendations', 0)}"
                )
                print(f"   Critical priority: {summary.get('critical_priority', 0)}")

                # Show immediate actions if available
                roadmap = report.get("implementation_roadmap", {})
                immediate_actions = len(roadmap.get("phase_1_immediate", []))
                if immediate_actions > 0:
                    print(f"üö® {immediate_actions} immediate actions recommended")

            if result.get("stdout"):
                print("\n" + result["stdout"])

        elif result["status"] == "disabled":
            print("‚ö†Ô∏è  Recommendations analysis is disabled for this project")
            print("üí° Use 'bootstrap intelligence config' to enable features")
        else:
            print(
                f"‚ùå Recommendations analysis failed: {result.get('message', 'Unknown error')}"
            )
            return 1

        return 0

    def _handle_full_analysis(self, intelligence: "IntelligenceCoordinator", args):
        """Handle full intelligence analysis command"""
        print(f"üß† Running comprehensive intelligence analysis for {args.project}...")

        result = intelligence.run_full_analysis(args.project)

        print(f"üìä Analysis Status: {result.get('overall_status', 'unknown')}")

        analyses = result.get("analyses", {})
        for analysis_type, analysis_result in analyses.items():
            status_icon = (
                "‚úÖ"
                if analysis_result["status"] == "success"
                else "‚ö†Ô∏è" if analysis_result["status"] == "disabled" else "‚ùå"
            )
            print(f"   {status_icon} {analysis_type}: {analysis_result['status']}")

        # Show summary information from successful analyses
        successful_analyses = [
            name for name, res in analyses.items() if res["status"] == "success"
        ]
        if successful_analyses:
            print(f"\nüìà Successfully completed: {', '.join(successful_analyses)}")
            print("üí° Check individual report files for detailed results")

        return 0

    def _handle_intelligence_config(
        self, intelligence: "IntelligenceCoordinator", args
    ):
        """Handle intelligence configuration command"""
        if args.enable:
            feature_names = [f"{feature}_enabled" for feature in args.enable]
            intelligence.enable_intelligence_features(args.project, feature_names)
            print(
                f"‚úÖ Enabled intelligence features for {args.project}: {', '.join(args.enable)}"
            )

        if args.disable:
            feature_names = [f"{feature}_enabled" for feature in args.disable]
            intelligence.disable_intelligence_features(args.project, feature_names)
            print(
                f"üîá Disabled intelligence features for {args.project}: {', '.join(args.disable)}"
            )

        if not args.enable and not args.disable:
            # Show current configuration
            config = intelligence.registry.get_intelligence_config(args.project)
            print(f"üìã Intelligence configuration for {args.project}:")
            print(
                f"   Auto-fix: {'enabled' if config.get('auto_fix_enabled', False) else 'disabled'}"
            )
            print(
                f"   Optimization: {'enabled' if config.get('optimization_enabled', False) else 'disabled'}"
            )
            print(
                f"   Predictions: {'enabled' if config.get('predictions_enabled', False) else 'disabled'}"
            )
            print(
                f"   Recommendations: {'enabled' if config.get('recommendations_enabled', False) else 'disabled'}"
            )

        return 0

    def cmd_health(self, args):
        """Check project health"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project not in projects:
            print(f"‚ùå Project '{args.project}' not found in registry")
            return 1

        config = projects[args.project]
        project_path = Path(config["path"])

        if not project_path.exists():
            print(f"‚ùå Project path does not exist: {project_path}")
            return 1

        print(f"üè• Health check for {args.project}...")

        health_checks = []

        # Check if project directory exists and is accessible
        health_checks.append(("Project Directory", project_path.exists()))

        # Check if it's a git repository
        health_checks.append(("Git Repository", (project_path / ".git").exists()))

        # Check for project config
        health_checks.append(
            ("Project Config", (project_path / ".project-config.yaml").exists())
        )

        # Check for essential scripts
        scripts_dir = project_path / "scripts"
        essential_scripts = ["validate-compliance.sh", "deploy.sh", "smart-commit.sh"]
        for script in essential_scripts:
            script_path = scripts_dir / script
            health_checks.append(
                (f"Script: {script}", script_path.exists() and script_path.is_file())
            )

        # Check for documentation
        docs = ["README.md", "CHANGELOG.md", "CONTRIBUTING.md"]
        for doc in docs:
            doc_path = project_path / doc
            health_checks.append((f"Documentation: {doc}", doc_path.exists()))

        # Display results
        print("\nüìä Health Check Results:")
        print("=" * 50)

        all_healthy = True
        for check_name, is_healthy in health_checks:
            status = "‚úÖ" if is_healthy else "‚ùå"
            print(f"{status} {check_name}")
            if not is_healthy:
                all_healthy = False

        if all_healthy:
            print(f"\nüéâ {args.project} is healthy!")
            return 0
        else:
            print(f"\n‚ö†Ô∏è  {args.project} has health issues that should be addressed")
            return 1

    def cmd_logs(self, args):
        """View project logs"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if args.project not in projects:
            print(f"‚ùå Project '{args.project}' not found in registry")
            return 1

        config = projects[args.project]
        project_path = Path(config["path"])

        print(f"üìã Viewing logs for {args.project}...")

        # Look for common log locations
        log_locations = [
            project_path / "logs",
            project_path / "temp" / "logs",
            project_path / ".logs",
        ]

        found_logs = False
        for log_dir in log_locations:
            if log_dir.exists() and log_dir.is_dir():
                print(f"\nüìÇ Logs in {log_dir}:")
                for log_file in log_dir.glob("*.log"):
                    file_size = log_file.stat().st_size
                    print(f"   üìÑ {log_file.name} ({file_size} bytes)")
                    if args.tail:
                        print(f"   Last {args.tail} lines:")
                        try:
                            result = subprocess.run(
                                ["tail", f"-{args.tail}", str(log_file)],
                                capture_output=True,
                                text=True,
                            )
                            if result.stdout:
                                for line in result.stdout.strip().split("\n"):
                                    print(f"      {line}")
                        except Exception as e:
                            print(f"      Error reading log: {e}")
                found_logs = True

        if not found_logs:
            print("‚ö†Ô∏è  No log files found in standard locations")
            print("üí° Try checking:")
            print("   ‚Ä¢ Docker container logs: docker logs <container>")
            print("   ‚Ä¢ GCP Cloud Logging: gcloud logging read")
            print("   ‚Ä¢ Application-specific log paths")

        return 0

    def cmd_status(self, args):
        """Show overall status of projects"""
        registry = self.load_registry()
        projects = registry.get("projects", {})

        if not projects:
            print("üìù No projects found in registry")
            return

        print("üìä Project Status Overview:")
        print("=" * 80)

        total_projects = len(projects)
        healthy_projects = 0
        missing_projects = 0

        for name, config in projects.items():
            path = Path(config.get("path", ""))
            exists = path.exists()

            if not exists:
                missing_projects += 1
                status = "‚ùå MISSING"
            else:
                # Quick health check
                has_config = (path / ".project-config.yaml").exists()
                has_git = (path / ".git").exists()
                has_readme = (path / "README.md").exists()

                health_score = sum([has_config, has_git, has_readme])
                if health_score >= 2:
                    healthy_projects += 1
                    status = "‚úÖ HEALTHY"
                else:
                    status = f"‚ö†Ô∏è  NEEDS ATTENTION ({health_score}/3)"

            project_type = config.get("type", "unknown")
            language = config.get("language", "unknown")

            print(f"{status:<20} {name:<25} {project_type:<15} {language}")

        print("=" * 80)
        print(
            f"Summary: {healthy_projects}/{total_projects} healthy, {missing_projects} missing"
        )

    def cmd_isolation(self, args):
        """Manage isolation and security features"""
        actions = {
            "validate": self._validate_isolation,
            "setup": self._setup_isolation,
            "rotate": self._rotate_credentials,
            "scan": self._scan_compliance,
            "guard": self._enable_guardrails,
        }

        action_func = actions.get(args.isolation_action)
        if action_func:
            return action_func(args) or 0
        else:
            print(f"‚ùå Unknown isolation action: {args.isolation_action}")
            print(f"Available actions: {', '.join(actions.keys())}")
            return 1

    def _validate_isolation(self, args):
        """Validate isolation configuration"""
        print("üîí Validating isolation configuration...")

        isolation_script = (
            self.bootstrap_root / "isolation" / "validation" / "isolation_validator.sh"
        )
        if isolation_script.exists():
            result = subprocess.run(
                [str(isolation_script)], capture_output=True, text=True
            )
            print(result.stdout)
            return result.returncode
        else:
            print("‚ö†Ô∏è  Isolation validator not found")
            return 1

    def _setup_isolation(self, args):
        """Setup isolation for a project"""
        if not hasattr(args, "project") or not args.project:
            print("‚ùå Please specify a project name")
            return 1

        print(f"üîê Setting up isolation for {args.project}...")

        registry = self.load_registry()
        if args.project not in registry.get("projects", {}):
            print(f"‚ùå Project '{args.project}' not found")
            return 1

        project_config = registry["projects"][args.project]
        cloud_provider = project_config.get("cloud_provider", "gcp")

        # Run appropriate isolation setup
        if cloud_provider == "gcp":
            script = (
                self.bootstrap_root
                / "isolation"
                / "gcp"
                / "scripts"
                / "bootstrap_gcloud.sh"
            )
        elif cloud_provider == "aws":
            script = (
                self.bootstrap_root
                / "isolation"
                / "aws"
                / "scripts"
                / "bootstrap_aws.sh"
            )
        else:
            print(f"‚ö†Ô∏è  No isolation setup for {cloud_provider}")
            return 1

        if script.exists():
            env = os.environ.copy()
            env["PROJECT_NAME"] = args.project
            env["PROJECT_PATH"] = project_config["path"]

            result = subprocess.run(
                [str(script)], env=env, capture_output=True, text=True
            )
            print(result.stdout)
            return result.returncode
        else:
            print(f"‚ö†Ô∏è  Isolation setup script not found: {script}")
            return 1

    def _rotate_credentials(self, args):
        """Rotate credentials for security"""
        print("üîÑ Rotating credentials...")

        rotation_script = (
            self.bootstrap_root
            / "isolation"
            / "credentials"
            / "rotation"
            / "rotate_credentials.sh"
        )
        if rotation_script.exists():
            result = subprocess.run(
                [str(rotation_script)], capture_output=True, text=True
            )
            print(result.stdout)
            return result.returncode
        else:
            print("‚ö†Ô∏è  Credential rotation script not found")
            return 1

    def _scan_compliance(self, args):
        """Scan for compliance issues"""
        print("üîç Scanning for compliance issues...")

        compliance_script = (
            self.bootstrap_root
            / "isolation"
            / "policies"
            / "compliance"
            / "compliance_scanner.sh"
        )
        if compliance_script.exists():
            result = subprocess.run(
                [str(compliance_script)], capture_output=True, text=True
            )
            print(result.stdout)
            return result.returncode
        else:
            print("‚ö†Ô∏è  Compliance scanner not found")
            return 1

    def _enable_guardrails(self, args):
        """Enable production guardrails"""
        print("üõ°Ô∏è  Enabling production guardrails...")

        guardrails_script = (
            self.bootstrap_root / "isolation" / "safety" / "production_guardrails.sh"
        )
        if guardrails_script.exists():
            result = subprocess.run(
                [str(guardrails_script)], capture_output=True, text=True
            )
            print(result.stdout)
            return result.returncode
        else:
            print("‚ö†Ô∏è  Guardrails script not found")
            return 1

    def main(self):
        """Main CLI entry point"""
        parser = argparse.ArgumentParser(
            description="Universal Project Bootstrap CLI",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=__doc__,
        )

        subparsers = parser.add_subparsers(dest="command", help="Available commands")

        # New project command
        new_parser = subparsers.add_parser("new", help="Create a new project")
        new_parser.add_argument("name", help="Project name")
        new_parser.add_argument(
            "--type",
            choices=["api", "web-app", "cli", "library", "infrastructure"],
            default="api",
            help="Project type",
        )
        new_parser.add_argument(
            "--language",
            choices=["python", "javascript", "go", "rust", "auto"],
            default="auto",
            help="Primary language",
        )
        new_parser.add_argument(
            "--cloud",
            choices=["gcp", "aws", "azure"],
            default="gcp",
            help="Cloud provider",
        )
        new_parser.add_argument("--team", help="Owning team")
        new_parser.add_argument(
            "--criticality",
            choices=["low", "medium", "high"],
            default="medium",
            help="Project criticality",
        )
        new_parser.add_argument("--path", help="Custom project path")
        new_parser.add_argument(
            "--git", action="store_true", help="Initialize Git repository"
        )

        # Retrofit command
        retrofit_parser = subparsers.add_parser(
            "retrofit", help="Update existing project"
        )
        retrofit_parser.add_argument("path", help="Path to existing project")
        retrofit_parser.add_argument(
            "--type",
            choices=["api", "web-app", "cli", "library", "infrastructure"],
            help="Override detected project type",
        )

        # List command
        list_parser = subparsers.add_parser("list", help="List all managed projects")

        # Validate command
        validate_parser = subparsers.add_parser(
            "validate", help="Validate project compliance"
        )
        validate_parser.add_argument("project", help="Project name or 'all'")

        # Registry command
        registry_parser = subparsers.add_parser(
            "registry", help="Manage project registry"
        )
        registry_parser.add_argument(
            "action",
            choices=[
                "validate",
                "update",
                "show",
                "clean",
                "backup",
                "restore",
                "stats",
                "export",
            ],
            help="Registry action",
        )
        registry_parser.add_argument(
            "--backup-file", help="Backup file to restore from"
        )
        registry_parser.add_argument(
            "--format",
            choices=["yaml", "json", "csv"],
            default="yaml",
            help="Export format",
        )
        registry_parser.add_argument("--output", help="Output file for export")

        # Deploy command
        deploy_parser = subparsers.add_parser("deploy", help="Deploy a project")
        deploy_parser.add_argument("project", help="Project name")
        deploy_parser.add_argument(
            "environment", nargs="?", default="dev", help="Target environment"
        )

        # Infrastructure command
        infra_parser = subparsers.add_parser("infra", help="Infrastructure operations")
        infra_parser.add_argument(
            "action",
            choices=["init", "plan", "apply", "destroy", "validate", "fmt", "cost"],
            help="Infrastructure action",
        )
        infra_parser.add_argument("project", help="Project name")
        infra_parser.add_argument(
            "--auto-approve", action="store_true", help="Auto-approve apply/destroy"
        )
        infra_parser.add_argument("--var-file", help="Terraform variable file")

        # Intelligence command
        intelligence_parser = subparsers.add_parser(
            "intelligence", help="AI-driven analysis and automation"
        )
        intelligence_subparsers = intelligence_parser.add_subparsers(
            dest="intelligence_action", help="Intelligence operations"
        )

        # Auto-fix sub-command
        autofix_parser = intelligence_subparsers.add_parser(
            "autofix", help="Detect and fix common issues"
        )
        autofix_parser.add_argument("project", help="Project name")
        autofix_parser.add_argument(
            "--apply", action="store_true", help="Automatically apply fixes"
        )

        # Optimization sub-command
        optimize_parser = intelligence_subparsers.add_parser(
            "optimize", help="Analyze optimization opportunities"
        )
        optimize_parser.add_argument("project", help="Project name")
        optimize_parser.add_argument(
            "--category",
            choices=["cost", "performance", "resource", "security"],
            help="Focus on specific optimization category",
        )

        # Predictions sub-command
        predict_parser = intelligence_subparsers.add_parser(
            "predict", help="Predict future issues and capacity needs"
        )
        predict_parser.add_argument("project", help="Project name")
        predict_parser.add_argument(
            "--timeframe",
            choices=["immediate", "short", "medium", "long"],
            help="Focus on specific timeframe",
        )

        # Recommendations sub-command
        recommend_parser = intelligence_subparsers.add_parser(
            "recommend", help="Get best practice recommendations"
        )
        recommend_parser.add_argument("project", help="Project name")
        recommend_parser.add_argument(
            "--priority",
            choices=["critical", "high", "medium", "low"],
            help="Filter by priority level",
        )
        recommend_parser.add_argument(
            "--category",
            choices=[
                "architecture",
                "security",
                "performance",
                "maintainability",
                "reliability",
            ],
            help="Filter by category",
        )

        # Full analysis sub-command
        analyze_parser = intelligence_subparsers.add_parser(
            "analyze", help="Run comprehensive intelligence analysis"
        )
        analyze_parser.add_argument("project", help="Project name")
        analyze_parser.add_argument(
            "--modules",
            nargs="+",
            choices=["autofix", "optimize", "predict", "recommend"],
            help="Specific modules to run (default: all enabled)",
        )

        # Intelligence config sub-command
        config_parser = intelligence_subparsers.add_parser(
            "config", help="Configure intelligence features"
        )
        config_parser.add_argument("project", help="Project name")
        config_parser.add_argument(
            "--enable",
            nargs="+",
            choices=["autofix", "optimize", "predict", "recommend"],
            help="Enable intelligence features",
        )
        config_parser.add_argument(
            "--disable",
            nargs="+",
            choices=["autofix", "optimize", "predict", "recommend"],
            help="Disable intelligence features",
        )

        # Health command
        health_parser = subparsers.add_parser("health", help="Check project health")
        health_parser.add_argument("project", help="Project name")

        # Logs command
        logs_parser = subparsers.add_parser("logs", help="View project logs")
        logs_parser.add_argument("project", help="Project name")
        logs_parser.add_argument(
            "--tail", type=int, default=50, help="Number of lines to show"
        )
        logs_parser.add_argument(
            "--follow", "-f", action="store_true", help="Follow log output"
        )

        # Status command
        status_parser = subparsers.add_parser(
            "status", help="Show overall project status"
        )

        # Isolation command
        isolation_parser = subparsers.add_parser(
            "isolation", help="Manage isolation and security"
        )
        isolation_parser.add_argument(
            "isolation_action",
            choices=["validate", "setup", "rotate", "scan", "guard"],
            help="Isolation action to perform",
        )
        isolation_parser.add_argument(
            "--project", help="Project name for isolation setup"
        )

        args = parser.parse_args()

        if not args.command:
            parser.print_help()
            return 0

        # Map commands to methods
        command_map = {
            "new": self.cmd_new,
            "retrofit": self.cmd_retrofit,
            "list": self.cmd_list,
            "validate": self.cmd_validate,
            "registry": self.cmd_registry,
            "deploy": self.cmd_deploy,
            "infra": self.cmd_infra,
            "intelligence": self.cmd_intelligence,
            "health": self.cmd_health,
            "logs": self.cmd_logs,
            "status": self.cmd_status,
            "isolation": self.cmd_isolation,
        }

        handler = command_map.get(args.command)
        if handler:
            try:
                return handler(args) or 0
            except KeyboardInterrupt:
                print("\n‚ùå Operation cancelled")
                return 1
            except Exception as e:
                print(f"‚ùå Error: {e}")
                return 1
        else:
            print(f"‚ùå Unknown command: {args.command}")
            return 1


if __name__ == "__main__":
    cli = BootstrapCLI()
    sys.exit(cli.main())
